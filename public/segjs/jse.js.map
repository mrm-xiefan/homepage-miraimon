{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 52535a8f84e825060f4c","webpack:///./js/main.js","webpack:///./js/app/edit.js","webpack:///./js/image/layer.js","webpack:///./js/helper/segment-annotator.js","webpack:///./js/image/segmentation.js","webpack:///./js/image/segmentation/pff.js","webpack:///./js/image/segmentation/base.js","webpack:///./js/image/compat.js","webpack:///./js/image/segmentation/slic.js","webpack:///./js/image/segmentation/slico.js","webpack:///./js/image/segmentation/watershed.js","webpack:///./js/image/segmentation/binary-heap-priority-queue.js","webpack:///./js/image/canny.js","webpack:///./js/image/distance-transform.js","webpack:///./js/image/morph.js","webpack:///./js/image/morph/max-filter.js","webpack:///./js/image/morph/neighbor-map.js","webpack:///./js/helper/util.js","webpack:///./js/helper/colormap.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAoD,kBAAkB,EAAE;AACxE;AACA;AACA,qDAAoD,kBAAkB,EAAE;AACxE;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,6BAA6B;AAChD;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,mBAAmB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,YAAW,YAAY;AACvB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,qBAAqB;AACtC;AACA,kBAAiB,yBAAyB;AAC1C;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACraA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,oCAAoC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC,oBAAmB,iBAAiB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB,gBAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;;AAGA;;;;;;;ACxNA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B,6BAA4B;AAC5B,8BAA6B;AAC7B,kCAAiC;AACjC;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,gCAAgC,EAAE;AAC3D;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,4CAA2C,cAAc,EAAE;AAC3D;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB,yBAAyB;AAC3C;AACA,uCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,oCAAoC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,kBAAkB;AAC/B,gBAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,kBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA,wBAAuB;AACvB;AACA,iBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACjsBA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,mDAAkD;AAClD,gBAAe,YAAY;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,YAAY;AAC3B,kBAAiB,WAAW;AAC5B,oBAAmB,OAAO;AAC1B;AACA,sBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,YAAY;AAC3B,kBAAiB,WAAW;AAC5B,oBAAmB,OAAO;AAC1B;AACA,sBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,oBAAmB,YAAY;AAC/B,sBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA,gCAA+B,oBAAoB,EAAE;AACrD;AACA;AACA;AACA,gBAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B,sBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;AC3UD;AACA;AACA;AACA;AACA;AACA,4FACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,EAAC;;;;;;;ACnBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,KAAK;AACxB,sBAAqB,OAAO;AAC5B,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,4BAA4B;AAC/D,sCAAqC,4BAA4B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA,mBAAkB,eAAe;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,wBAAwB;AAC3C;AACA;AACA,wBAAuB,kCAAkC;AACzD;AACA;AACA,oCAAmC,4BAA4B;AAC/D,sCAAqC,2BAA2B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB;AAChB;AACA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC;AACA,kBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,kBAAkB;AACxC;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;AC1dD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,qBAAqB;AACxC,sBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B,4CAA2C;AAC3C,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,aAAa;AAChC;AACA,sBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA,sBAAqB,gBAAgB;AACrC,iCAAgC;AAChC,4DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,iBAAiB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA,qBAAoB,QAAQ;AAC5B,uBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,oBAAmB,iBAAiB;AACpC,sBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,WAAW;AAChC,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC,sBAAqB,gBAAgB;AACrC;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB;AAChB;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;ACzfD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAkC,oBAAoB;AACtD,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,gBAAe,mBAAmB;AAClC;AACA,gBAAe,kBAAkB;AACjC;AACA,gBAAe,kBAAkB;AACjC;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,sBAAsB;AAC1C;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA,qBAAoB,sBAAsB;AAC1C;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,qBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB;AACpB;AACA,qBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAsB;AACtB;AACA,qBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA,sBAAqB,YAAY;AACjC,wBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,EAAC;;;;;;;AClUD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA,sCAAqC,cAAc;AACnD,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,8DAA6D,cAAc;AAC3E;AACA;AACA;AACA,sBAAqB,uBAAuB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;;;;;;ACzFD;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,UAAU;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,kBAAkB;AAC/B;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,yBAAyB;AACtC;AACA;AACA;AACA,gBAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,YAAY;AAC3B,qBAAoB,kBAAkB;AACtC;AACA;AACA,oBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,mBAAmB;AACrC,kBAAiB,WAAW;AAC5B;AACA;AACA,oBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,gBAAgB;AAC7B,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,gBAAgB;AAC7B,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA2B,cAAc,EAAE;AAC3C;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,WAAW;AACxB,gBAAe,YAAY;AAC3B;AACA;AACA,gBAAe,YAAY;AAC3B;AACA;AACA;AACA,cAAa,YAAY;AACzB,gBAAe,WAAW;AAC1B;AACA;AACA,gBAAe,WAAW;AAC1B;AACA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC3FA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA,cAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/CA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA,sBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B,sBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA,sBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACjED;AACA;AACA;AACA;AACA;AACA,qDAAoD,WAAW;AAC/D,iDAAgD,WAAW;AAC3D,+CAA8C,YAAY;AAC1D;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,gBAAe,WAAW;AAC1B;AACA,gBAAe,kBAAkB;AACjC;AACA,gBAAe,WAAW;AAC1B;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,OAAO,OAAO;AAChC,mBAAkB,OAAO,OAAO;AAChC,mBAAkB,OAAO,OAAO;AAChC,mBAAkB,OAAO,OAAO;AAChC,mBAAkB,OAAO,OAAO;AAChC,mBAAkB,OAAO,OAAO;AAChC;AACA,sCAAqC,4BAA4B,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"jse.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Jse\"] = factory();\n\telse\n\t\troot[\"Jse\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 52535a8f84e825060f4c","/* Main page dispatcher.\n*/\nvar editor = require('./app/edit');\nvar colormap = require('./helper/colormap');\n\nmodule.exports = {\n  Editor: editor.Editor,\n  colormap: colormap\n}\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/main.js\n// module id = 0\n// module chunks = 0","/** Editor page renderer.\n */\nvar Layer = require('../image/layer').Layer;\nvar Annotator = require('../helper/segment-annotator').Annotator;\nvar util = require('../helper/util');\n\n\n\n// Create the main content block.\nfunction createMainDisplay(data, annotator, imageLayer) {\n  var container = document.createElement(\"div\"),\n    imageContainerSpacer = document.createElement(\"div\"),\n    imageContainer = document.createElement(\"div\"),\n    annotatorTopMenu = createImageTopMenu(annotator),\n    annotatorContainer = document.createElement(\"div\"),\n    sidebarSpacer = document.createElement(\"div\"),\n    sidebarContainer = document.createElement(\"div\"),\n    sidebar = createSidebar(data, annotator);\n  imageContainerSpacer.className = \"edit-image-top-menu\";\n  imageContainer.className = \"edit-image-display\";\n  imageContainer.appendChild(imageContainerSpacer);\n  imageContainer.appendChild(imageLayer.canvas);\n  annotatorContainer.className = \"edit-image-display\";\n  annotatorContainer.appendChild(annotatorTopMenu);\n  annotatorContainer.appendChild(annotator.container);\n  sidebarSpacer.className = \"edit-image-top-menu\";\n  sidebarContainer.className = \"edit-image-display\";\n  sidebarContainer.appendChild(sidebarSpacer);\n  sidebarContainer.appendChild(sidebar);\n  container.className = \"edit-main-container\";\n  container.appendChild(imageContainer);\n  container.appendChild(annotatorContainer);\n  container.appendChild(sidebarContainer);\n  return container;\n}\n\n// Create the menu above the editor.\nfunction createImageTopMenu(annotator) {\n  var container = document.createElement(\"div\"),\n    zoomOutButton = document.createElement(\"div\"),\n    zoomInButton = document.createElement(\"div\"),\n    spacer1 = document.createElement(\"span\"),\n    finerButton = document.createElement(\"div\"),\n    boundaryButton = document.createElement(\"div\"),\n    coarserButton = document.createElement(\"div\"),\n    spacer2 = document.createElement(\"span\"),\n    alphaMinusButton = document.createElement(\"div\"),\n    imageButton = document.createElement(\"div\"),\n    alphaPlusButton = document.createElement(\"div\");\n  zoomOutButton.appendChild(document.createTextNode(\"-\"));\n  zoomOutButton.classList.add(\"edit-image-top-button\");\n  zoomOutButton.addEventListener(\"click\", function () {\n    annotator.zoomOut();\n  });\n  zoomInButton.appendChild(document.createTextNode(\"zoom +\"));\n  zoomInButton.classList.add(\"edit-image-top-button\");\n  zoomInButton.addEventListener(\"click\", function () {\n    annotator.zoomIn();\n  });\n  spacer1.className = \"edit-image-top-spacer\";\n  boundaryButton.id = \"boundary-button\";\n  boundaryButton.className = \"edit-image-top-button\";\n  boundaryButton.appendChild(document.createTextNode(\"boundary\"));\n  boundaryButton.addEventListener(\"click\", function () {\n    if (boundaryFlashTimeoutID)\n      window.clearTimeout(boundaryFlashTimeoutID);\n    if (boundaryButton.classList.contains(\"edit-image-top-button-enabled\"))\n      annotator.hide(\"boundary\");\n    else\n      annotator.show(\"boundary\");\n    boundaryButton.classList.toggle(\"edit-image-top-button-enabled\");\n  });\n  finerButton.appendChild(document.createTextNode(\"-\"));\n  finerButton.className = \"edit-image-top-button\";\n  finerButton.addEventListener(\"click\", function () {\n    annotator.finer();\n    boundaryFlash();\n  });\n  coarserButton.appendChild(document.createTextNode(\"+\"));\n  coarserButton.className = \"edit-image-top-button\";\n  coarserButton.addEventListener(\"click\", function () {\n    annotator.coarser();\n    boundaryFlash();\n  });\n  spacer2.className = \"edit-image-top-spacer\";\n  alphaMinusButton.className = \"edit-image-top-button\";\n  alphaMinusButton.appendChild(document.createTextNode(\"-\"));\n  alphaMinusButton.addEventListener(\"click\", function () {\n    annotator.moreAlpha();\n  });\n  imageButton.className = \"edit-image-top-button \" +\n    \"edit-image-top-button-enabled\";\n  imageButton.appendChild(document.createTextNode(\"image\"));\n  imageButton.addEventListener(\"click\", function () {\n    if (imageButton.classList.contains(\"edit-image-top-button-enabled\"))\n      annotator.hide(\"image\");\n    else\n      annotator.show(\"image\");\n    imageButton.classList.toggle(\"edit-image-top-button-enabled\");\n  });\n  alphaPlusButton.className = \"edit-image-top-button\";\n  alphaPlusButton.appendChild(document.createTextNode(\"+\"));\n  alphaPlusButton.addEventListener(\"click\", function () {\n    annotator.lessAlpha();\n  });\n  //\n  container.className = \"edit-image-top-menu\";\n  container.appendChild(zoomOutButton);\n  container.appendChild(zoomInButton);\n  container.appendChild(spacer1);\n  container.appendChild(finerButton);\n  container.appendChild(boundaryButton);\n  container.appendChild(coarserButton);\n  container.appendChild(spacer2);\n  container.appendChild(alphaMinusButton);\n  container.appendChild(imageButton);\n  container.appendChild(alphaPlusButton);\n  return container;\n}\n\n// Set up the automatic flash of boundary.\nvar boundaryFlashTimeoutID = null;\nfunction boundaryFlash() {\n  var boundaryButton = document.getElementById(\"boundary-button\");\n  if (boundaryFlashTimeoutID) {\n    window.clearTimeout(boundaryFlashTimeoutID);\n    boundaryFlashTimeoutID = window.setTimeout(function () {\n      boundaryButton.click();\n      boundaryFlashTimeoutID = null;\n    }, 1000);\n  }\n  else if (!boundaryButton.classList.contains(\n    \"edit-image-top-button-enabled\")) {\n    boundaryButton.click();\n    boundaryFlashTimeoutID = window.setTimeout(function () {\n      boundaryButton.click();\n      boundaryFlashTimeoutID = null;\n    }, 1000);\n  }\n}\n\n// Create the sidebar.\nfunction createSidebar(data, annotator) {\n  var container = document.createElement(\"div\"),\n    labelPicker = createLabelPicker(data, annotator),\n    spacer1 = document.createElement(\"div\"),\n    undoButton = document.createElement(\"div\"),\n    redoButton = document.createElement(\"div\"),\n    spacer2 = document.createElement(\"div\"),\n    denoiseButton = document.createElement(\"div\"),\n    spacer3 = document.createElement(\"div\"),\n    superpixelToolButton = document.createElement(\"div\"),\n    spacer4 = document.createElement(\"div\"),\n    polygonToolButton = document.createElement(\"div\"),\n    spacer5 = document.createElement(\"div\"),\n    manualParagraph = document.createElement(\"p\"),\n    spacer6 = document.createElement(\"div\"),\n    manualText;\n  spacer1.className = \"edit-sidebar-spacer\";\n  undoButton.className = \"edit-sidebar-button\";\n  undoButton.appendChild(document.createTextNode(\"undo\"));\n  undoButton.addEventListener(\"click\", function () { annotator.undo(); });\n  redoButton.className = \"edit-sidebar-button\";\n  redoButton.appendChild(document.createTextNode(\"redo\"));\n  redoButton.addEventListener(\"click\", function () { annotator.redo(); });\n  spacer2.className = \"edit-sidebar-spacer\";\n  denoiseButton.className = \"edit-sidebar-button\";\n  denoiseButton.appendChild(document.createTextNode(\"denoise\"));\n  denoiseButton.addEventListener(\"click\", function () {\n    annotator.denoise();\n  });\n  superpixelToolButton.className = \"edit-sidebar-button\";\n  superpixelToolButton.appendChild(\n    document.createTextNode(\"Superpixel tool\"));\n  superpixelToolButton.addEventListener(\"click\", function () {\n    polygonToolButton.classList.remove(\"edit-sidebar-button-selected\");\n    superpixelToolButton.classList.add(\"edit-sidebar-button-selected\");\n    annotator._setMode(\"superpixel\");\n  });\n  superpixelToolButton.classList.add(\"edit-sidebar-button-selected\");\n  polygonToolButton.className = \"edit-sidebar-button\";\n  polygonToolButton.appendChild(document.createTextNode(\"Polygon tool\"));\n  polygonToolButton.addEventListener(\"click\", function () {\n    superpixelToolButton.classList.remove(\"edit-sidebar-button-selected\");\n    polygonToolButton.classList.add(\"edit-sidebar-button-selected\");\n    annotator._setMode(\"polygon\");\n  });\n  spacer3.className = \"edit-sidebar-spacer\";\n  manualParagraph.appendChild(document.createTextNode(\"ctrl: toggle mode\"));\n  manualParagraph.appendChild(document.createElement(\"br\"));\n  manualParagraph.appendChild(document.createElement(\"br\"));\n  manualParagraph.appendChild(document.createTextNode(\"+Superpixel tool:\"));\n  manualParagraph.appendChild(document.createElement(\"br\"));\n  manualParagraph.appendChild(document.createTextNode(\"left: mark\"));\n  manualParagraph.appendChild(document.createElement(\"br\"));\n  manualParagraph.appendChild(document.createTextNode(\"right: pick label\"));\n  manualParagraph.appendChild(document.createElement(\"br\"));\n  manualParagraph.appendChild(document.createElement(\"br\"));\n  manualParagraph.appendChild(document.createTextNode(\"+Polygon tool:\"));\n  manualParagraph.appendChild(document.createElement(\"br\"));\n  manualParagraph.appendChild(document.createTextNode(\"left: draw line\"));\n  manualParagraph.appendChild(document.createElement(\"br\"));\n  manualParagraph.appendChild(document.createTextNode(\"right: abort\"));\n  spacer4.className = \"edit-sidebar-spacer\";\n  container.className = \"edit-sidebar\";\n  container.appendChild(labelPicker);\n  container.appendChild(spacer1);\n  container.appendChild(undoButton);\n  container.appendChild(redoButton);\n  container.appendChild(spacer2);\n  container.appendChild(denoiseButton);\n  container.appendChild(spacer3);\n  container.appendChild(polygonToolButton);\n  container.appendChild(superpixelToolButton);\n  container.appendChild(manualParagraph);\n  return container;\n}\n\nfunction createLabelButton(options, value, index, annotator) {\n  var colorBox = document.createElement(\"span\"),\n    labelText = document.createElement(\"span\"),\n    pickButton = document.createElement(\"div\"),\n    popupButton = document.createElement(\"div\"),\n    popupContainer = document.createElement(\"div\");\n  colorBox.className = \"edit-sidebar-legend-colorbox\";\n  colorBox.style.backgroundColor =\n    \"rgb(\" + options.colormap.list[index].join(\",\") + \")\";\n  labelText.appendChild(document.createTextNode(value));\n  labelText.className = \"edit-sidebar-legend-label\";\n  popupButton.appendChild(document.createTextNode(\"+\"));\n  popupButton.className = \"edit-sidebar-popup-trigger\";\n  popupButton.addEventListener(\"click\", function () {\n    popupContainer.classList.toggle(\"edit-sidebar-popup-active\");\n  });\n  popupContainer.className = \"edit-sidebar-popup\";\n  popupContainer.appendChild(\n    createRelabelSelector(options, index, annotator, popupContainer)\n  );\n  popupContainer.addEventListener(\"click\", function (event) {\n    event.preventDefault();\n  });\n  pickButton.appendChild(colorBox);\n  pickButton.appendChild(labelText);\n  pickButton.appendChild(popupButton);\n  pickButton.appendChild(popupContainer);\n  pickButton.id = \"label-\" + index + \"-button\";\n  pickButton.className = \"edit-sidebar-button\";\n  pickButton.addEventListener(\"click\", function () {\n    var className = \"edit-sidebar-button-selected\";\n    annotator.currentLabel = index;\n    var selectedElements = document.getElementsByClassName(className);\n    for (var i = 0; i < selectedElements.length; ++i)\n      selectedElements[i].classList.remove(className);\n    pickButton.classList.add(className);\n  });\n  pickButton.addEventListener('mouseenter', function () {\n    if (!document.getElementsByClassName(\"edit-sidebar-popup-active\").length)\n      annotator.highlightLabel(index);\n  });\n  pickButton.addEventListener('mouseleave', function () {\n    if (!document.getElementsByClassName(\"edit-sidebar-popup-active\").length)\n      annotator.unhighlightLabel();\n  });\n  return pickButton;\n}\n\n// Hightlight legend labels.\nfunction highlightLabel(label) {\n  var highlightClass = \"edit-sidebar-button-highlight\",\n    elements = document.getElementsByClassName(highlightClass);\n  for (var i = 0; i < elements.length; ++i)\n    elements[i].classList.remove(highlightClass);\n  var pickButton = document.getElementById(\"label-\" + label + \"-button\");\n  if (pickButton)\n    pickButton.classList.add(highlightClass);\n}\n\n// Create the label picker button.\nfunction createLabelPicker(options, annotator) {\n  var container = document.createElement(\"div\");\n  container.className = \"edit-sidebar-label-picker\";\n  for (var i = 0; i < options.colormap.labels.length; ++i) {\n    var labelButton = createLabelButton(options, options.colormap.labels[i], i, annotator);\n    if (i === 0) {\n      annotator.currentLabel = 0;\n      labelButton.classList.add(\"edit-sidebar-button-selected\");\n    }\n    container.appendChild(labelButton);\n  }\n  window.addEventListener(\"click\", cancelPopup, true);\n  return container;\n}\n\n// Cancel popup.\nfunction cancelPopup(event) {\n  var isOutsidePopup = true,\n    target = event.target;\n  while (target.parentNode) {\n    isOutsidePopup = isOutsidePopup &&\n      !target.classList.contains(\"edit-sidebar-popup\");\n    target = target.parentNode;\n  }\n  if (isOutsidePopup) {\n    var popups = document.getElementsByClassName(\n      \"edit-sidebar-popup-active\");\n    if (popups.length)\n      for (var i = 0; i < popups.length; ++i)\n        popups[i].classList.remove(\"edit-sidebar-popup-active\");\n  }\n}\n\n// Create the relabel selector.\nfunction createRelabelSelector(options, index, annotator, popupContainer) {\n  var select = document.createElement(\"select\"),\n    firstOption = document.createElement(\"option\");\n  firstOption.appendChild(document.createTextNode(\"Change to\"));\n  select.appendChild(firstOption);\n  for (var i = 0; i < options.colormap.labels.length; ++i) {\n    if (i !== index) {\n      var option = document.createElement(\"option\");\n      option.value = i;\n      option.appendChild(document.createTextNode(options.colormap.labels[i]));\n      select.appendChild(option);\n    }\n  }\n  select.addEventListener(\"change\", function (event) {\n    var sourceLabel = index;\n    var targetLabel = parseInt(event.target.value, 10);\n    if (sourceLabel !== targetLabel) {\n      var currentLabel = annotator.currentLabel;\n      annotator.currentLabel = targetLabel;\n      annotator.fill(sourceLabel);\n      annotator.currentLabel = currentLabel;\n    }\n    popupContainer.classList.remove(\"edit-sidebar-popup-active\");\n    firstOption.selected = true;\n    event.preventDefault();\n  });\n  return select;\n}\n\n/**\n * @class\n * @param {HtmlElement} element - render element.\n * @param {object} colormap - created annotation image.\n * @param {string} colormap.labals - created annotation image.\n * @param {string} colormap.list - created annotation image.\n * @param {object} [options]\n * @param {number} options.width\n * @param {number} options.height\n * \n */\nfunction Editor(element, colormap, options) {\n  this._element = element;\n  this._colormap = colormap;\n  this._options = options || {};\n  this._options.colormap = this._colormap;\n}\n\nEditor.prototype._clear = function () {\n  var element = this._element;\n  while (element.firstChild) element.removeChild(element.firstChild);\n}\n\n/**\n * @method\n * @param {string} src\n * @param {string} annotation\n */\nEditor.prototype.render = function (src, annotation) {\n  var _this = this;\n  _this.image = {\n    src: src,\n    annotation: annotation\n  };\n\n  _this._clear()\n\n  var annotator = new Annotator(src, {\n    width: _this._options.width,\n    height: _this._options.height,\n    colormap: _this._colormap.list,\n    superpixelOptions: { method: \"slic\", regionSize: 25 },\n    onload: function () {\n      if (annotation)\n        annotator.import(annotation);\n      annotator.hide(\"boundary\");\n      boundaryFlash();\n    },\n    onchange: function () {\n      var activeLabels = this.getUniqueLabels(),\n        legendClass = \"edit-sidebar-legend-label\",\n        legendActiveClass = \"edit-sidebar-legend-label-active\",\n        elements = document.getElementsByClassName(legendClass),\n        i;\n      for (i = 0; i < elements.length; ++i)\n        elements[i].classList.remove(legendActiveClass);\n      for (i = 0; i < activeLabels.length; ++i)\n        elements[activeLabels[i]].classList.add(legendActiveClass);\n    },\n    onrightclick: function (label) {\n      document.getElementById(\"label-\" + label + \"-button\").click();\n    },\n    onmousemove: highlightLabel\n  });\n\n  var imageLayer = new Layer(src, {\n    width: _this._options.width,\n    height: _this._options.height\n  });\n\n  _this.annotator = annotator;\n\n  // append main display.\n  _this._element.appendChild(createMainDisplay(_this._options,\n    _this.annotator,\n    imageLayer));\n}\n\nmodule.exports = {\n  Editor: Editor\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/app/edit.js\n// module id = 1\n// module chunks = 0","/** Image canvas wrapper.\n *\n * Example:\n *\n *  var layer = new Layer(\"/path/to/image.jpg\", {\n *    onload: function () {\n *      this.resize(200, 300);\n *      document.body.appendChild(this.canvas);\n *    }\n *  });\n *\n * Copyright 2015  Kota Yamaguchi\n */\n'use strict';\n// Canvas wrapper object.\nfunction Layer(source, options) {\n  options = options || {};\n  this.canvas = document.createElement(\"canvas\");\n  this.canvas.width = options.width || this.canvas.width;\n  this.canvas.height = options.height || this.canvas.height;\n  if (source) {\n    if (typeof source === \"string\" ||\n      typeof source === \"object\" && source.nodeName === \"IMG\")\n      this.load(source, options);\n    else if (typeof source === \"object\" &&\n      (source.nodeName === \"CANVAS\" || source instanceof ImageData))\n      this.fromCanvas(source, options);\n  }\n}\n\nLayer.prototype.load = function (source, options) {\n  options = options || {};\n  if (typeof options === \"function\") options = { onload: options };\n  var image, layer = this;\n  this.canvas.width = options.width || this.canvas.width;\n  this.canvas.height = options.height || this.canvas.height;\n  if (typeof source === \"string\") {\n    image = new Image();\n    image.src = source;\n    image.crossOrigin = \"Anonymous\";\n  }\n  else\n    image = source;\n  image.onload = function () { layer._onImageLoad(image, options); };\n  if (typeof options.onerror === \"function\")\n    image.onerror = options.onerror.call(this);\n  return this;\n};\n\nLayer.prototype._onImageLoad = function (image, options) {\n  this.canvas.width = options.width || image.width;\n  this.canvas.height = options.height || image.height;\n  var context = this.canvas.getContext(\"2d\");\n  this._setImageSmoothing(context, options);\n  context.drawImage(image, 0, 0, image.width, image.height,\n    0, 0, this.canvas.width, this.canvas.height);\n  this.imageData = context.getImageData(0, 0,\n    this.canvas.width,\n    this.canvas.height);\n  if (typeof options.onload === \"function\")\n    options.onload.call(this);\n};\n\nLayer.prototype.fromCanvas = function (source, options) {\n  options = options || {};\n  if (typeof options === \"function\") options = { onload: options };\n  this.canvas.width = source.width;\n  this.canvas.height = source.height;\n  var context = this.canvas.getContext(\"2d\");\n  this._setImageSmoothing(context, options);\n  if (source instanceof ImageData)\n    context.putImageData(source, 0, 0);\n  else\n    context.drawImage(source, 0, 0, this.canvas.width, this.canvas.height);\n  this.imageData = context.getImageData(0, 0,\n    this.canvas.width,\n    this.canvas.height);\n  if (typeof options.onload === \"function\")\n    options.onload.call(this);\n  return this;\n};\n\nLayer.prototype.fromImageData = function (imageData, options) {\n  options = options || {};\n  if (typeof options === \"function\") options = { onload: options };\n  this.canvas.width = imageData.width;\n  this.canvas.height = imageData.height;\n  var context = this.canvas.getContext(\"2d\");\n  this._setImageSmoothing(context, options);\n  context.drawImage(imageData, 0, 0, this.canvas.width, this.canvas.height);\n  this.imageData = context.getImageData(0, 0,\n    this.canvas.width,\n    this.canvas.height);\n  if (typeof options.onload === \"function\")\n    options.onload.call(this);\n  return this;\n};\n\nLayer.prototype._setImageSmoothing = function (context, options) {\n  if (typeof options.imageSmoothingEnabled === \"undefined\")\n    options.imageSmoothingEnabled = true;\n  context.mozImageSmoothingEnabled = options.imageSmoothingEnabled;\n  context.webkitImageSmoothingEnabled = options.imageSmoothingEnabled;\n  context.msImageSmoothingEnabled = options.imageSmoothingEnabled;\n  context.imageSmoothingEnabled = options.imageSmoothingEnabled;\n};\n\nLayer.prototype.copy = function (source) {\n  source.render();\n  this.fromCanvas(source.canvas);\n  return this;\n};\n\nLayer.prototype.process = function (callback) {\n  if (typeof callback !== \"function\")\n    throw \"Invalid callback\";\n  callback.call(this, this.imageData);\n  return this.render();\n};\n\nLayer.prototype.render = function () {\n  if (this.imageData)\n    this.canvas.getContext(\"2d\").putImageData(this.imageData, 0, 0);\n  return this;\n};\n\nLayer.prototype.setAlpha = function (alpha) {\n  var data = this.imageData.data;\n  for (var i = 3; i < data.length; i += 4)\n    data[i] = alpha;\n  return this;\n};\n\nLayer.prototype.fill = function (rgba) {\n  var data = this.imageData.data;\n  for (var i = 0; i < data.length; i += 4)\n    for (var j = 0; j < rgba.length; ++j)\n      data[i + j] = rgba[j];\n  return this;\n};\n\nLayer.prototype.resize = function (width, height, options) {\n  options = options || {};\n  var temporaryCanvas = document.createElement(\"canvas\"),\n    tempoaryContext = temporaryCanvas.getContext(\"2d\");\n  temporaryCanvas.width = width;\n  temporaryCanvas.height = height;\n  tempoaryContext.drawImage(this.canvas, 0, 0, width, height);\n  this.canvas.width = width;\n  this.canvas.height = height;\n  var context = this.canvas.getContext(\"2d\");\n  this._setImageSmoothing(context, options);\n  context.drawImage(temporaryCanvas, 0, 0);\n  this.imageData = context.getImageData(0, 0, width, height);\n  return this;\n};\n\nLayer.prototype.applyColormap = function (colormap, grayscale) {\n  var data = this.imageData.data;\n  if (typeof grayscale === \"undefined\") grayscale = true;\n  for (var i = 0; i < data.length; i += 4) {\n    var index = data[i];\n    if (!grayscale)\n      index |= (data[i + 1] << 8) | (data[i + 2] << 16);\n    data[i + 0] = colormap[index][0];\n    data[i + 1] = colormap[index][1];\n    data[i + 2] = colormap[index][2];\n  }\n  return this;\n};\n\nLayer.prototype.computeEdgemap = function (options) {\n  if (typeof options === \"undefined\") options = {};\n  var data = this.imageData.data,\n    width = this.imageData.width,\n    height = this.imageData.height,\n    edgeMap = new Uint8Array(this.imageData.data),\n    foreground = options.foreground || [255, 255, 255],\n    background = options.background || [0, 0, 0],\n    i, j, k;\n  for (i = 0; i < height; ++i) {\n    for (j = 0; j < width; ++j) {\n      var offset = 4 * (i * width + j),\n        index = data[4 * (i * width + j)],\n        isBoundary = (i === 0 ||\n          j === 0 ||\n          i === (height - 1) ||\n          j === (width - 1) ||\n          index !== data[4 * (i * width + j - 1)] ||\n          index !== data[4 * (i * width + j + 1)] ||\n          index !== data[4 * ((i - 1) * width + j)] ||\n          index !== data[4 * ((i + 1) * width + j)]);\n      if (isBoundary) {\n        for (k = 0; k < foreground.length; ++k)\n          edgeMap[offset + k] = foreground[k];\n      }\n      else {\n        for (k = 0; k < background.length; ++k)\n          edgeMap[offset + k] = background[k];\n      }\n    }\n  }\n  data.set(edgeMap);\n  return this;\n};\n\nLayer.prototype.gray2index = function () {\n  var data = this.imageData.data;\n  for (var i = 0; i < data.length; i += 4) {\n    data[i + 1] = 0;\n    data[i + 2] = 0;\n  }\n  return this;\n};\n\n\nexports.Layer = Layer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/layer.js\n// module id = 2\n// module chunks = 0","/**\n * Segment annotation widget.\n *\n * var annotator = new SegmentAnnotator(\"/path/to/image.jpg\", {\n *   onload: function () {},\n *   onerror: function () {},\n *   onchange: function () {},\n *   onrightclick: function () {},\n *   onleftclick: function () {}\n * });\n * document.body.appendChild(annotator.container);\n *\n * Copyright 2015  Kota Yamaguchi\n */\nvar Layer = require('../image/layer').Layer;\nvar segmentation = require('../image/segmentation');\nvar morph = require('../image/morph');\n\n// Segment annotator.\nfunction Annotator(imageURL, options) {\n  options = options || {};\n  if (typeof imageURL !== \"string\") {\n    throw \"Invalid imageURL\";\n  }\n  this.colormap = options.colormap || [[255, 255, 255], [255, 0, 0]];\n  this.boundaryColor = options.boundaryColor || [255, 255, 255];\n  this.boundaryAlpha = options.boundaryAlpha || 127;\n  this.visualizationAlpha = options.visualizationAlpha || 144;\n  this.highlightAlpha = options.highlightAlpha ||\n    Math.min(255, this.visualizationAlpha + 128);\n  this.currentZoom = 1.0;\n  this.defaultLabel = options.defaultLabel || 0;\n  this.maxHistoryRecord = options.maxHistoryRecord || 10;\n  this.onchange = options.onchange || null;\n  this.onrightclick = options.onrightclick || null;\n  this.onleftclick = options.onleftclick || null;\n  this.onhighlight = options.onhighlight || null;\n  this.onmousemove = options.onmousemove || null;\n  this._createLayers(options);\n  this._initializeHistory(options);\n  this._createLayers(options);\n  this._initializeHistory(options);\n  this.mode = \"superpixel\";\n  this.polygonPoints = [];\n  this.prevAnnotationImg = null;\n  var annotator = this;\n  this.layers.image.load(imageURL, {\n    width: options.width,\n    height: options.height,\n    onload: function () { annotator._initialize(options); },\n    onerror: options.onerror\n  });\n}\n\n// Run superpixel segmentation.\nAnnotator.prototype.resetSuperpixels = function (options) {\n  options = options || {};\n  this.layers.superpixel.copy(this.layers.image);\n  this.segmentation = segmentation.create(this.layers.image.imageData,\n    options);\n  this._updateSuperpixels(options);\n  return this;\n};\n\n// Adjust the superpixel resolution.\nAnnotator.prototype.finer = function (options) {\n  this.segmentation.finer();\n  this._updateSuperpixels(options);\n  return this;\n};\n\n// Adjust the superpixel resolution.\nAnnotator.prototype.coarser = function (options) {\n  this.segmentation.coarser();\n  this._updateSuperpixels(options);\n  return this;\n};\n\n// Undo the edit.\nAnnotator.prototype.undo = function () {\n  if (this.currentHistoryRecord < 0)\n    return false;\n  var record = this.history[this.currentHistoryRecord--];\n  this._fillPixels(record.pixels, record.prev);\n  this.layers.visualization.render();\n  if (typeof this.onchange === \"function\")\n    this.onchange.call(this);\n  return this.currentHistoryRecord < 0;\n};\n\n// Redo the edit.\nAnnotator.prototype.redo = function () {\n  if (this.currentHistoryRecord >= this.history.length - 1)\n    return false;\n  var record = this.history[++this.currentHistoryRecord];\n  this._fillPixels(record.pixels, record.next);\n  this.layers.visualization.render();\n  if (typeof this.onchange === \"function\")\n    this.onchange.call(this);\n  return this.currentHistoryRecord >= this.history.length;\n};\n\n// Get unique labels in the current annotation.\nAnnotator.prototype.getUniqueLabels = function () {\n  var uniqueIndex = [],\n    data = this.layers.annotation.imageData.data;\n  for (var i = 0; i < data.length; i += 4) {\n    var label = _getEncodedLabel(data, i);\n    if (uniqueIndex.indexOf(label) < 0) {\n      uniqueIndex.push(label);\n    }\n  }\n  return uniqueIndex.sort(function (a, b) { return a - b; });\n};\n\n// Fill all the pixels assigned the target label or all.\nAnnotator.prototype.fill = function (targetLabel) {\n  var pixels = [],\n    annotationData = this.layers.annotation.imageData.data;\n  for (var i = 0; i < annotationData.length; i += 4) {\n    var label = _getEncodedLabel(annotationData, i);\n    if (label === targetLabel || targetLabel === undefined)\n      pixels.push(i);\n  }\n  if (pixels.length > 0)\n    this._updateAnnotation(pixels, this.currentLabel);\n  return this;\n};\n\nAnnotator.prototype.setAlpha = function (alpha) {\n  this.visualizationAlpha = Math.max(Math.min(alpha, 255), 0);\n  this.layers.visualization.setAlpha(this.visualizationAlpha).render();\n  return this;\n};\n\nAnnotator.prototype.lessAlpha = function (scale) {\n  return this.setAlpha(this.visualizationAlpha - (scale || 1) * 20);\n};\n\nAnnotator.prototype.moreAlpha = function (scale) {\n  return this.setAlpha(this.visualizationAlpha + (scale || 1) * 20);\n};\n\n// Import an existing annotation.\nAnnotator.prototype.import = function (annotationURL, options) {\n  options = options || {};\n  var annotator = this;\n  this.layers.annotation.load(annotationURL, {\n    onload: function () {\n      if (options.grayscale)\n        this.gray2index();\n      annotator.layers\n        .visualization\n        .copy(this)\n        .applyColormap(annotator.colormap)\n        .setAlpha(annotator.visualizationAlpha)\n        .render();\n      this.setAlpha(0).render();\n      this.history = [];\n      this.currentHistoryRecord = -1;\n      if (typeof options.onload === \"function\")\n        options.onload.call(annotator);\n      if (typeof annotator.onchange === \"function\")\n        annotator.onchange.call(annotator);\n    },\n    onerror: options.onerror\n  });\n  return this;\n};\n\n// Export the annotation in data URL.\nAnnotator.prototype.export = function (isBlob) {\n  this.layers.annotation.setAlpha(255);\n  this.layers.annotation.render();\n  if (isBlob)\n    var data = isBlob\n      ? this.layers.annotation.canvas.toBlob()\n      : this.layers.annotation.canvas.toDataURL();\n  this.layers.annotation.setAlpha(0);\n  this.layers.annotation.render();\n  return data;\n};\n\n// Show a specified layer.\nAnnotator.prototype.show = function (layer) {\n  this.layers[layer].canvas.style.display = \"inline-block\";\n  return this;\n};\n\n// Hide a specified layer.\nAnnotator.prototype.hide = function (layer) {\n  this.layers[layer].canvas.style.display = \"none\";\n  return this;\n};\n\n// Highlight a specified label.\nAnnotator.prototype.highlightLabel = function (label) {\n  var pixels = [],\n    annotationData = this.layers.annotation.imageData.data;\n  for (var i = 0; i < annotationData.length; i += 4) {\n    var currentLabel = _getEncodedLabel(annotationData, i);\n    if (currentLabel === label)\n      pixels.push(i);\n  }\n  this._updateHighlight(pixels);\n  return this;\n};\n\n// Disable highlight.\nAnnotator.prototype.unhighlightLabel = function () {\n  this._updateHighlight(null);\n  return this;\n};\n\n// Zoom to specific resolution.\nAnnotator.prototype.zoom = function (scale) {\n  this.currentZoom = Math.max(Math.min(scale || 1.0, 10.0), 1.0);\n  this.innerContainer.style.zoom = this.currentZoom;\n  this.innerContainer.style.MozTransform =\n    \"scale(\" + this.currentZoom + \")\";\n  return this;\n};\n\n// Zoom in.\nAnnotator.prototype.zoomIn = function (scale) {\n  return this.zoom(this.currentZoom + (scale || 0.25));\n};\n\n// Zoom out.\nAnnotator.prototype.zoomOut = function (scale) {\n  return this.zoom(this.currentZoom - (scale || 0.25));\n};\n\n// // Align the current annotation to the boundary of superpixels.\n// Annotator.prototype.alignBoundary = function () {\n//   var annotationData = this.layers.annotation.imageData.data;\n//   for (var i = 0; i < this.pixelIndex.length; ++i) {\n//     var pixels = this.pixelIndex[i],\n//         label = _findMostFrequent(annotationData, pixels);\n//     this._fillPixels(pixels, label);\n//   }\n//   this.layers.visualization.render();\n//   this.history = [];\n//   this.currentHistoryRecord = 0;\n// };\n\nAnnotator.prototype.denoise = function () {\n  var indexImage = morph.decodeIndexImage(this.layers.annotation.imageData),\n    result = morph.maxFilter(indexImage);\n  var pixels = new Int32Array(result.data.length);\n  for (var i = 0; i < pixels.length; ++i)\n    pixels[i] = 4 * i;\n  this._updateAnnotation(pixels, result.data);\n  return this;\n};\n\n// Private methods.\n\nAnnotator.prototype._createLayers = function (options) {\n  var onload = options.onload;\n  delete options.onload;\n  this.container = document.createElement(\"div\");\n  this.container.classList.add(\"segment-annotator-outer-container\");\n  this.innerContainer = document.createElement(\"div\");\n  this.innerContainer.classList.add(\"segment-annotator-inner-container\");\n  this.layers = {\n    image: new Layer(options),\n    superpixel: new Layer(options),\n    visualization: new Layer(options),\n    boundary: new Layer(options),\n    annotation: new Layer(options)\n  };\n  options.onload = onload;\n  for (var key in this.layers) {\n    var canvas = this.layers[key].canvas;\n    canvas.classList.add(\"segment-annotator-layer\");\n    this.innerContainer.appendChild(canvas);\n  }\n  this.container.appendChild(this.innerContainer);\n  this._resizeLayers(options);\n};\n\nAnnotator.prototype._resizeLayers = function (options) {\n  this.width = options.width || this.layers.image.canvas.width;\n  this.height = options.height || this.layers.image.canvas.height;\n  for (var key in this.layers) {\n    if (key !== \"image\") {\n      var canvas = this.layers[key].canvas;\n      canvas.width = this.width;\n      canvas.height = this.height;\n    }\n  }\n  this.innerContainer.style.width = this.width + \"px\";\n  this.innerContainer.style.height = this.height + \"px\";\n  this.container.style.width = this.width + \"px\";\n  this.container.style.height = this.height + \"px\";\n};\n\nAnnotator.prototype._initializeHistory = function (options) {\n  this.history = [];\n  this.currentHistoryRecord = -1;\n};\n\nAnnotator.prototype._initialize = function (options) {\n  options = options || {};\n  if (!options.width)\n    this._resizeLayers(options);\n  this._initializeAnnotationLayer();\n  this._initializeVisualizationLayer();\n  this._initializeEvents();\n  this.resetSuperpixels(options.superpixelOptions);\n  if (typeof options.onload === \"function\")\n    options.onload.call(this);\n  if (typeof this.onchange === \"function\")\n    this.onchange.call(this);\n};\n\nAnnotator.prototype._initializeEvents = function () {\n  var canvas = this.layers.annotation.canvas,\n    mousestate = { down: false, button: 0 },\n    annotator = this;\n  canvas.oncontextmenu = function () { return false; };\n  function updateIfActive(event) {\n    var offset = annotator._getClickOffset(event),\n      superpixelData = annotator.layers.superpixel.imageData.data,\n      annotationData = annotator.layers.annotation.imageData.data,\n      superpixelIndex = _getEncodedLabel(superpixelData, offset),\n      pixels = annotator.pixelIndex[superpixelIndex],\n      existingLabel = _getEncodedLabel(annotationData, offset);\n    if (annotator.mode === \"superpixel\")\n      annotator._updateHighlight(pixels);\n    if (typeof annotator.onmousemove === \"function\")\n      annotator.onmousemove.call(annotator, existingLabel);\n    if (mousestate.down) {\n      if (mousestate.button == 2 &&\n        typeof annotator.onrightclick === \"function\") {\n        if (annotator.mode === \"polygon\")\n          annotator._emptyPolygonPoints(); //reset\n        else\n          annotator.onrightclick.call(annotator, existingLabel);\n      } else {\n        if (event.button === 0 && annotator.mode === \"polygon\") {\n          annotator._addPolygonPoint(event);\n          if (annotator._checkLineIntersection())\n            annotator._addPolygonToAnnotation();\n        } else {\n          annotator._updateAnnotation(pixels, annotator.currentLabel);\n        }\n        if (typeof annotator.onleftclick === \"function\")\n          annotator.onleftclick.call(annotator, annotator.currentLabel);\n      }\n    }\n  }\n  canvas.addEventListener('mousemove', updateIfActive);\n  canvas.addEventListener('mouseup', updateIfActive);\n  canvas.addEventListener('mouseleave', function () {\n    annotator._updateHighlight(null);\n    if (typeof annotator.onmousemove === \"function\") {\n      annotator.onmousemove.call(annotator, null);\n    }\n  });\n  canvas.addEventListener('mousedown', function (event) {\n    mousestate.down = true;\n    mousestate.button = event.button;\n  });\n  window.addEventListener('mouseup', function () {\n    mousestate.down = false;\n  });\n  //polygon on/off with ctrl-key\n  window.onkeyup = function (e) {\n    var key = e.keyCode ? e.keyCode : e.which;\n    if (key == 17) {\n      if (annotator.mode == \"polygon\") {\n        annotator.mode = \"superpixel\";\n      } else {\n        annotator.mode = \"polygon\";\n        annotator._updateHighlight(null);\n      }\n      annotator._emptyPolygonPoints();\n    }\n  };\n};\n\nAnnotator.prototype._updateBoundaryLayer = function () {\n  var boundaryLayer = this.layers.boundary;\n  boundaryLayer.copy(this.layers.superpixel);\n  boundaryLayer.computeEdgemap({\n    foreground: this.boundaryColor.concat(this.boundaryAlpha),\n    background: this.boundaryColor.concat(0)\n  });\n  boundaryLayer.render();\n};\n\nAnnotator.prototype._initializeAnnotationLayer = function () {\n  var layer = this.layers.annotation;\n  layer.resize(this.width, this.height);\n  this.currentLabel = this.defaultLabel;\n  layer.fill([this.defaultLabel, 0, 0, 0]);\n  layer.render();\n};\n\nAnnotator.prototype._initializeVisualizationLayer = function () {\n  var layer = this.layers.visualization;\n  layer.resize(this.width, this.height);\n  var initialColor = this.colormap[this.defaultLabel]\n    .concat([this.visualizationAlpha]);\n  layer.fill(initialColor);\n  layer.render();\n};\n\nAnnotator.prototype._updateSuperpixels = function () {\n  var annotator = this;\n  this.layers.superpixel.process(function (imageData) {\n    imageData.data.set(annotator.segmentation.result.data);\n    annotator._createPixelIndex(annotator.segmentation.result.numSegments);\n    annotator._updateBoundaryLayer();\n    this.setAlpha(0).render();\n  });\n};\n\nAnnotator.prototype._createPixelIndex = function (numSegments) {\n  var pixelIndex = new Array(numSegments),\n    data = this.layers.superpixel.imageData.data,\n    i;\n  for (i = 0; i < numSegments; ++i)\n    pixelIndex[i] = [];\n  for (i = 0; i < data.length; i += 4) {\n    var index = data[i] | (data[i + 1] << 8) | (data[i + 2] << 16);\n    pixelIndex[index].push(i);\n  }\n  this.currentPixels = null;\n  this.pixelIndex = pixelIndex;\n};\n\nAnnotator.prototype._getClickOffset = function (event) {\n  var pos = this._getClickPos(event),\n    x = pos[0],\n    y = pos[1];\n  return 4 * (y * this.layers.visualization.canvas.width + x);\n};\n\nAnnotator.prototype._getClickPos = function (event) {\n  var container = this.container,\n    containerRect = container.getBoundingClientRect(), win = window, docElem = document.documentElement,\n    offsetLeft = containerRect.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),\n    offsetTop = containerRect.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n    x = Math.round(\n      (event.pageX - offsetLeft + container.scrollLeft) *\n      (container.offsetWidth / container.scrollWidth)\n    ),\n    y = Math.round(\n      (event.pageY - offsetTop + container.scrollTop) *\n      (container.offsetHeight / container.scrollHeight)\n    ),\n    x = Math.max(Math.min(x, this.layers.visualization.canvas.width - 1), 0);\n  y = Math.max(Math.min(y, this.layers.visualization.canvas.height - 1), 0);\n  return [x, y];\n};\n\n// polygon tool.\nAnnotator.prototype._addPolygonPoint = function (event) {\n  var annotator = this,\n    pos = this._getClickPos(event),\n    x = pos[0],\n    y = pos[1];\n  //get canvas.\n  var canvas = annotator.layers.annotation.canvas,\n    ctx = canvas.getContext('2d');\n  if (this.polygonPoints.length === 0) {\n    ctx.save();  // remember previous state.\n    annotator.prevAnnotationImg =\n      ctx.getImageData(0, 0, canvas.width, canvas.height);\n  }\n  // draw.\n  ctx.fillStyle = '#FA6900';\n  ctx.strokeStyle = \"#000000\";\n  ctx.lineWidth = 1;\n  if (this.polygonPoints.length === 0) {\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n  } else {\n    ctx.lineTo(x, y);\n    ctx.stroke();\n  }\n  this.polygonPoints.push(pos);\n};\n\nAnnotator.prototype._emptyPolygonPoints = function () {\n  var annotator = this,\n    ctx = annotator.layers.annotation.canvas.getContext('2d');\n  ctx.restore();\n  if (annotator.prevAnnotationImg)\n    ctx.putImageData(annotator.prevAnnotationImg, 0, 0);\n  //reset polygon-points\n  annotator.polygonPoints = [];\n};\n\nAnnotator.prototype._addPolygonToAnnotation = function () {\n  var annotator = this,\n    canvas = document.createElement('canvas'),\n    x, y;\n  // set canvas dimensions.\n  canvas.width = annotator.layers.annotation.canvas.width;\n  canvas.height = annotator.layers.annotation.canvas.height;\n  var ctx = canvas.getContext('2d');\n  ctx.fillStyle = \"rgba(0, 0, 255, 255)\";\n  ctx.beginPath();\n  ctx.moveTo(annotator.polygonPoints[0][0], annotator.polygonPoints[0][1]);\n  for (i = 1; i < annotator.polygonPoints.length; ++i) {\n    x = annotator.polygonPoints[i][0];\n    y = annotator.polygonPoints[i][1];\n    ctx.lineTo(x, y);\n  }\n  ctx.lineTo(annotator.polygonPoints[0][0], annotator.polygonPoints[0][1]);\n  ctx.closePath();\n  ctx.fill();\n  //get pixels within polygon.\n  var colorToCheck = [0, 0, 255, 255],\n    imageData = ctx.getImageData(0, 0, canvas.width, canvas.height),\n    data = imageData.data,\n    pixelsPolygon = [];\n  for (x = 0; x < canvas.width; ++x) {\n    for (y = 0; y < canvas.height; ++y) {\n      var index = (x + y * imageData.width) * 4;\n      if (data[index + 0] == colorToCheck[0] &&\n        data[index + 1] == colorToCheck[1] &&\n        data[index + 2] == colorToCheck[2] &&\n        data[index + 3] == colorToCheck[3]) {\n        pixelsPolygon.push(index);\n      }\n    }\n  }\n  // update annotation.\n  annotator._updateAnnotation(pixelsPolygon, annotator.currentLabel);\n  annotator._emptyPolygonPoints();\n};\n\nAnnotator.prototype._checkLineIntersection = function () {\n  if (this.polygonPoints.length < 4)\n    return false;\n  var newLineStartX = this.polygonPoints[this.polygonPoints.length - 2][0],\n    newLineStartY = this.polygonPoints[this.polygonPoints.length - 2][1],\n    newLineEndX = this.polygonPoints[this.polygonPoints.length - 1][0],\n    newLineEndY = this.polygonPoints[this.polygonPoints.length - 1][1];\n\n  for (i = 1; i < this.polygonPoints.length - 2; ++i) {\n    var line1StartX = this.polygonPoints[i - 1][0],\n      line1StartY = this.polygonPoints[i - 1][1],\n      line1EndX = this.polygonPoints[i][0],\n      line1EndY = this.polygonPoints[i][1],\n      denominator =\n        ((newLineEndY - newLineStartY) * (line1EndX - line1StartX)) -\n        ((newLineEndX - newLineStartX) * (line1EndY - line1StartY)),\n      a = line1StartY - newLineStartY,\n      b = line1StartX - newLineStartX,\n      numerator1 = ((newLineEndX - newLineStartX) * a) -\n        ((newLineEndY - newLineStartY) * b),\n      numerator2 = ((line1EndX - line1StartX) * a) -\n        ((line1EndY - line1StartY) * b);\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n    if (a > 0 && a < 1 && b > 0 && b < 1)\n      return true;\n  }\n  return false;\n};\n\nAnnotator.prototype._setMode = function (mode) {\n  this.mode = mode;\n};\n\nAnnotator.prototype._updateHighlight = function (pixels) {\n  var visualizationData = this.layers.visualization.imageData.data,\n    boundaryData = this.layers.boundary.imageData.data,\n    annotationData = this.layers.annotation.imageData.data,\n    i,\n    color,\n    offset;\n  if (this.currentPixels !== null) {\n    for (i = 0; i < this.currentPixels.length; ++i) {\n      offset = this.currentPixels[i];\n      color = this.colormap[_getEncodedLabel(annotationData, offset)];\n      visualizationData[offset + 0] = color[0];\n      visualizationData[offset + 1] = color[1];\n      visualizationData[offset + 2] = color[2];\n      visualizationData[offset + 3] = this.visualizationAlpha;\n    }\n  }\n  this.currentPixels = pixels;\n  if (this.currentPixels !== null) {\n    for (i = 0; i < pixels.length; ++i) {\n      offset = pixels[i];\n      if (boundaryData[offset + 3]) {\n        visualizationData[offset + 0] = this.boundaryColor[0];\n        visualizationData[offset + 1] = this.boundaryColor[1];\n        visualizationData[offset + 2] = this.boundaryColor[2];\n        visualizationData[offset + 3] = this.highlightAlpha;\n      }\n      else {\n        visualizationData[offset + 3] = this.highlightAlpha;\n      }\n    }\n  }\n  this.layers.visualization.render();\n  this.layers.boundary.render();\n  if (typeof this.onhighlight === \"function\")\n    this.onhighlight.call(this);\n};\n\nAnnotator.prototype._fillPixels = function (pixels, labels) {\n  if (pixels.length !== labels.length)\n    throw \"Invalid fill: \" + pixels.length + \" !== \" + labels.length;\n  var annotationData = this.layers.annotation.imageData.data,\n    visualizationData = this.layers.visualization.imageData.data;\n  for (var i = 0; i < pixels.length; ++i) {\n    var offset = pixels[i],\n      label = labels[i],\n      color = this.colormap[label];\n    _setEncodedLabel(annotationData, offset, label);\n    visualizationData[offset + 0] = color[0];\n    visualizationData[offset + 1] = color[1];\n    visualizationData[offset + 2] = color[2];\n  }\n};\n\n// Update label.\nAnnotator.prototype._updateAnnotation = function (pixels, labels) {\n  var updates;\n  labels = (typeof labels === \"object\") ?\n    labels : _fillArray(new Int32Array(pixels.length), labels);\n  updates = this._getDifferentialUpdates(pixels, labels);\n  if (updates.pixels.length === 0)\n    return this;\n  this._updateHistory(updates);\n  this._fillPixels(updates.pixels, updates.next);\n  this.layers.visualization.render();\n  if (typeof this.onchange === \"function\")\n    this.onchange.call(this);\n  return this;\n};\n\n// Get the differential update of labels.\nAnnotator.prototype._getDifferentialUpdates = function (pixels, labels) {\n  if (pixels.length !== labels.length)\n    throw \"Invalid labels\";\n  var annotationData = this.layers.annotation.imageData.data,\n    updates = { pixels: [], prev: [], next: [] };\n  for (var i = 0; i < pixels.length; ++i) {\n    var label = _getEncodedLabel(annotationData, pixels[i]);\n    if (label !== labels[i]) {\n      updates.pixels.push(pixels[i]);\n      updates.prev.push(label);\n      updates.next.push(labels[i]);\n    }\n  }\n  return updates;\n};\n\nAnnotator.prototype._updateHistory = function (updates) {\n  this.history = this.history.slice(0, this.currentHistoryRecord + 1);\n  this.history.push(updates);\n  if (this.history.length > this.maxHistoryRecord)\n    this.history = this.history.slice(1, this.history.length);\n  else\n    ++this.currentHistoryRecord;\n};\n\nfunction _fillArray(array, value) {\n  for (var i = 0; i < array.length; ++i)\n    array[i] = value;\n  return array;\n}\n\n// function _findMostFrequent(annotationData, pixels) {\n//   var histogram = {},\n//       j;\n//   for (j = 0; j < pixels.length; ++j) {\n//     var label = _getEncodedLabel(annotationData, pixels[j]);\n//     histogram[label] = (histogram[label]) ? histogram[label] + 1 : 1;\n//   }\n//   var maxFrequency = 0,\n//       majorLabel = 0;\n//   for (j in histogram) {\n//     var frequency = histogram[j];\n//     if (frequency > maxFrequency) {\n//       maxFrequency = frequency;\n//       majorLabel = j;\n//     }\n//   }\n//   return majorLabel;\n// }\n\nfunction _getEncodedLabel(array, offset) {\n  return array[offset] |\n    (array[offset + 1] << 8) |\n    (array[offset + 2] << 16);\n}\n\nfunction _setEncodedLabel(array, offset, label) {\n  array[offset + 0] = label & 255;\n  array[offset + 1] = (label >>> 8) & 255;\n  array[offset + 2] = (label >>> 16) & 255;\n  array[offset + 3] = 255;\n}\n\nexports.Annotator = Annotator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/helper/segment-annotator.js\n// module id = 3\n// module chunks = 0","/** Image segmentation factory.\n *\n *  var segm = segmentation.create(imageData);\n *  var segmentData = segm.result;  // imageData with numSegments.\n *\n *  segm.finer();\n *  segm.coarser();\n *\n * Copyright 2015  Kota Yamaguchi\n */\nvar pff = require('./segmentation/pff')\nvar slic = require('./segmentation/slic')\nvar slico = require('./segmentation/slico')\nvar watershed = require('./segmentation/watershed')\n\nvar methods = {\n  pff: pff,\n  slic: slic,\n  slico: slico,\n  watershed: watershed\n};\n\nmethods.create = function (imageData, options) {\n  options = options || {};\n  options.method = options.method || \"slic\";\n  if (!methods[options.method])\n    throw \"Invalid method: \" + options.method;\n  return new methods[options.method](imageData, options);\n};\n\nmodule.exports = methods;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/segmentation.js\n// module id = 4\n// module chunks = 0","/**\n * Javascript implementation of an image segmentation algorithm of\n *\n *    Efficient Graph-Based Image Segmentation\n *    Pedro F. Felzenszwalb and Daniel P. Huttenlocher\n *    International Journal of Computer Vision, 59(2) September 2004.\n *\n * API\n * ---\n *\n *    new PFF(imageData, options)\n *\n * The function takes the following options.\n * * `sigma` - Parameter for Gaussian pre-smoothing. Default 0.5.\n * * `threshold` - Threshold value of the algorithm. Default 500.\n * * `minSize` - Minimum segment size in pixels. Default 20.\n *\n * Copyright 2015  Kota Yamaguchi\n */\ndefine([\"./base\",\n        \"../compat\"],\nfunction(BaseSegmentation, compat) {\n  function PFF(imageData, options) {\n    BaseSegmentation.call(this, imageData, options);\n    options = options || {};\n    this.sigma = options.sigma || Math.sqrt(2.0);\n    this.threshold = options.threshold || 500;\n    this.minSize = options.minSize || 20;\n    this.result = this._compute();\n  }\n\n  PFF.prototype = Object.create(BaseSegmentation.prototype);\n\n  // Compute segmentation.\n  PFF.prototype._compute = function () {\n    var smoothedImage = compat.createImageData(this.imageData.width,\n                                               this.imageData.height);\n    smoothedImage.data.set(this.imageData.data);\n    smoothImage(smoothedImage, this.sigma);\n    var universe = segmentGraph(smoothedImage, this.threshold, this.minSize),\n        indexMap = createIndexMap(universe, smoothedImage),\n        result = compat.createImageData(smoothedImage.width,\n                                        smoothedImage.height);\n    encodeLabels(indexMap, result.data);\n    result.numSegments = universe.nodes;\n    return result;\n  };\n\n  // Finer.\n  PFF.prototype.finer = function (scale) {\n    this.sigma /= (scale || Math.sqrt(2));\n    this.threshold /= (scale || Math.sqrt(2));\n    this.result = this._compute();\n  };\n\n  // Coarser.\n  PFF.prototype.coarser = function (scale) {\n    this.sigma *= (scale || Math.sqrt(2.0));\n    this.threshold *= (scale || Math.sqrt(2.0));\n    this.result = this._compute();\n  };\n\n  // Create a normalized Gaussian filter.\n  function createGaussian(sigma) {\n    sigma = Math.max(sigma, 0.01);\n    var length = Math.ceil(sigma * 4) + 1,\n        mask = new Float32Array(length),\n        sumValues = 0,\n        i;\n    for (i = 0; i < length; ++i) {\n      var value = Math.exp(-0.5 * Math.pow(i / sigma, 2));\n      sumValues += Math.abs(value);\n      mask[i] = value;\n    }\n    sumValues = 2 * sumValues - Math.abs(mask[0]); // 2x except center.\n    for (i = 0; i < length; ++i)\n      mask[i] /= sumValues;\n    return mask;\n  }\n\n  // Convolve even.\n  function convolveEven(imageData, filter) {\n    var width = imageData.width,\n        height = imageData.height,\n        source = imageData.data,\n        temporary = new Float32Array(source),\n        i,\n        j,\n        k,\n        l,\n        sum;\n    // Horizontal filter.\n    for (i = 0; i < height; ++i) {\n      for (j = 0; j < width; ++j) {\n        for (k = 0; k < 3; ++k) {\n          sum = filter[0] * source[4 * (i * width + j) + k];\n          for (l = 1; l < filter.length; ++l) {\n            sum += filter[l] * (\n              source[4 * (i * width + Math.max(j - l, 0)) + k] +\n              source[4 * (i * width + Math.min(j + l, width - 1)) + k]\n              );\n          }\n          temporary[4 * (i * width + j) + k] = sum;\n        }\n      }\n    }\n    // Vertical filter.\n    for (i = 0; i < height; ++i) {\n      for (j = 0; j < width; ++j) {\n        for (k = 0; k < 3; ++k) {\n          sum = filter[0] * temporary[4 * (i * width + j) + k];\n          for (l = 1; l < filter.length; ++l) {\n            sum += filter[l] * (\n              temporary[4 * (Math.max(i - l, 0) * width + j) + k] +\n              temporary[4 * (Math.min(i + l, height - 1) * width + j) + k]\n              );\n          }\n          source[4 * (i * width + j) + k] = sum;\n        }\n      }\n    }\n  }\n\n  // Smooth an image.\n  function smoothImage(imageData, sigma) {\n    var gaussian = createGaussian(sigma);\n    convolveEven(imageData, gaussian);\n  }\n\n  // Create an edge structure.\n  function createEdges(imageData) {\n    var width = imageData.width,\n        height = imageData.height,\n        rgbData = imageData.data,\n        edgeSize = 4 * width * height - 3 * width - 3 * height + 2,\n        index = 0,\n        edges = {\n          a: new Int32Array(edgeSize),\n          b: new Int32Array(edgeSize),\n          w: new Float32Array(edgeSize)\n        },\n        x1,\n        x2;\n    for (var i = 0; i < height; ++i) {\n      for (var j = 0; j < width; ++j) {\n        if (j < width - 1) {\n          x1 = i * width + j;\n          x2 = i * width + j + 1;\n          edges.a[index] = x1;\n          edges.b[index] = x2;\n          x1 = 4 * x1;\n          x2 = 4 * x2;\n          edges.w[index] = Math.sqrt(\n            Math.pow(rgbData[x1 + 0] - rgbData[x2 + 0], 2) +\n            Math.pow(rgbData[x1 + 1] - rgbData[x2 + 1], 2) +\n            Math.pow(rgbData[x1 + 2] - rgbData[x2 + 2], 2)\n            );\n          ++index;\n        }\n        if (i < height - 1) {\n          x1 = i * width + j;\n          x2 = (i + 1) * width + j;\n          edges.a[index] = x1;\n          edges.b[index] = x2;\n          x1 = 4 * x1;\n          x2 = 4 * x2;\n          edges.w[index] = Math.sqrt(\n            Math.pow(rgbData[x1 + 0] - rgbData[x2 + 0], 2) +\n            Math.pow(rgbData[x1 + 1] - rgbData[x2 + 1], 2) +\n            Math.pow(rgbData[x1 + 2] - rgbData[x2 + 2], 2)\n            );\n          ++index;\n        }\n        if ((j < width - 1) && (i < height - 1)) {\n          x1 = i * width + j;\n          x2 = (i + 1) * width + j + 1;\n          edges.a[index] = x1;\n          edges.b[index] = x2;\n          x1 = 4 * x1;\n          x2 = 4 * x2;\n          edges.w[index] = Math.sqrt(\n            Math.pow(rgbData[x1 + 0] - rgbData[x2 + 0], 2) +\n            Math.pow(rgbData[x1 + 1] - rgbData[x2 + 1], 2) +\n            Math.pow(rgbData[x1 + 2] - rgbData[x2 + 2], 2)\n            );\n          ++index;\n        }\n        if ((j < width - 1) && (i > 0)) {\n          x1 = i * width + j;\n          x2 = (i - 1) * width + j + 1;\n          edges.a[index] = x1;\n          edges.b[index] = x2;\n          x1 = 4 * x1;\n          x2 = 4 * x2;\n          edges.w[index] = Math.sqrt(\n            Math.pow(rgbData[x1 + 0] - rgbData[x2 + 0], 2) +\n            Math.pow(rgbData[x1 + 1] - rgbData[x2 + 1], 2) +\n            Math.pow(rgbData[x1 + 2] - rgbData[x2 + 2], 2)\n            );\n          ++index;\n        }\n      }\n    }\n    return edges;\n  }\n\n  // Sort edges.\n  function sortEdgesByWeights(edges) {\n    var order = new Array(edges.w.length),\n        i;\n    for (i = 0; i < order.length; ++i)\n      order[i] = i;\n    var a = edges.a,\n        b = edges.b,\n        w = edges.w;\n    order.sort(function(i, j) { return w[i] - w[j]; });\n    var temporaryA = new Uint32Array(a),\n        temporaryB = new Uint32Array(b),\n        temporaryW = new Float32Array(w);\n    for (i = 0; i < order.length; ++i) {\n      temporaryA[i] = a[order[i]];\n      temporaryB[i] = b[order[i]];\n      temporaryW[i] = w[order[i]];\n    }\n    edges.a = temporaryA;\n    edges.b = temporaryB;\n    edges.w = temporaryW;\n  }\n\n  // Create a universe struct.\n  function createUniverse(nodes, c) {\n    var universe = {\n      nodes: nodes,\n      rank: new Int32Array(nodes),\n      p: new Int32Array(nodes),\n      size: new Int32Array(nodes),\n      threshold: new Float32Array(nodes)\n    };\n    for (var i = 0; i < nodes; ++i) {\n      universe.size[i] = 1;\n      universe.p[i] = i;\n      universe.threshold[i] = c;\n    }\n    return universe;\n  }\n\n  // Find a vertex pointing self.\n  function findNode(universe, index) {\n    var i = index;\n    while (i !== universe.p[i])\n      i = universe.p[i];\n    universe.p[index] = i;\n    return i;\n  }\n\n  // Join a node.\n  function joinNode(universe, a, b) {\n    if (universe.rank[a] > universe.rank[b]) {\n      universe.p[b] = a;\n      universe.size[a] += universe.size[b];\n    }\n    else {\n      universe.p[a] = b;\n      universe.size[b] += universe.size[a];\n      if (universe.rank[a] == universe.rank[b])\n        universe.rank[b]++;\n    }\n    universe.nodes--;\n  }\n\n  // Segment a graph.\n  function segmentGraph(imageData, c, minSize) {\n    var edges = createEdges(imageData),\n        a, b, i;\n    sortEdgesByWeights(edges);\n    var universe = createUniverse(imageData.width * imageData.height, c);\n    // Bottom-up merge.\n    for (i = 0; i < edges.a.length; ++i) {\n      a = findNode(universe, edges.a[i]);\n      b = findNode(universe, edges.b[i]);\n      if (a != b &&\n          edges.w[i] <= universe.threshold[a] &&\n          edges.w[i] <= universe.threshold[b]) {\n        joinNode(universe, a, b);\n        a = findNode(universe, a);\n        universe.threshold[a] = edges.w[i] + (c / universe.size[a]);\n      }\n    }\n    // Merge small components.\n    for (i = 0; i < edges.a.length; ++i) {\n      a = findNode(universe, edges.a[i]);\n      b = findNode(universe, edges.b[i]);\n      if (a != b &&\n          (universe.size[a] < minSize || universe.size[b] < minSize))\n        joinNode(universe, a, b);\n    }\n    return universe;\n  }\n\n  // Create an index map.\n  function createIndexMap(universe, imageData) {\n    var width = imageData.width,\n        height = imageData.height,\n        indexMap = new Int32Array(width * height),\n        nodeIds = [],\n        lastId = 0;\n    for (var i = 0; i < height; ++i) {\n      for (var j = 0; j < width; ++j) {\n        var component = findNode(universe, i * width + j),\n            index = nodeIds[component];\n        if (index === undefined) {\n          index = lastId;\n          nodeIds[component] = lastId++;\n        }\n        indexMap[i * width + j] = index;\n      }\n    }\n    return indexMap;\n  }\n\n  function encodeLabels(indexMap, data) {\n    for (var i = 0; i < indexMap.length; ++i) {\n      var value = indexMap[i];\n      data[4 * i + 0] = value & 255;\n      data[4 * i + 1] = (value >>> 8) & 255;\n      data[4 * i + 2] = (value >>> 16) & 255;\n      data[4 * i + 3] = 255;\n    }\n  }\n\n  return PFF;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/segmentation/pff.js\n// module id = 5\n// module chunks = 0","/**\n * Base class for over-segmentation algorithms.\n *\n * Copyright 2015  Kota Yamaguchi\n */\ndefine([\"../compat\"],\nfunction (compat) {\n  function BaseSegmentation(imageData, options) {\n    if (!(imageData instanceof ImageData))\n      throw \"Invalid ImageData\";\n    this.imageData = compat.createImageData(imageData.width, imageData.height);\n    this.imageData.data.set(imageData.data);\n  }\n\n  BaseSegmentation.prototype.finer = function () {};\n\n  BaseSegmentation.prototype.coarser = function () {};\n\n  return BaseSegmentation;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/segmentation/base.js\n// module id = 6\n// module chunks = 0","/** Compatibility API.\n *\n * Copyright 2015  Kota Yamaguchi\n */\n'use strict';\nmodule.exports = {\n  // Internet Explorer doesn't support ImageData().\n  createImageData: function (width, height) {\n    var context = document.createElement(\"canvas\").getContext(\"2d\");\n    return context.createImageData(width, height);\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/compat.js\n// module id = 7\n// module chunks = 0","/**\n * Javascript implementation of an image segmentation algorithm of\n *\n *    SLIC Superpixels\n *    Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal\n *    Fua, and Sabine Süsstrunk\n *    IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 34,\n *    num. 11, p. 2274 - 2282, May 2012.\n *\n * and based on the VLFeat implementation.\n *\n * API\n * ---\n *\n *    SLIC(imageURL, options)\n *\n * The function takes the following options.\n * * `regionSize` - Parameter of superpixel size\n * * `minRegionSize` - Minimum segment size in pixels.\n *\n * Copyright 2014  LongLong Yu.\n */\ndefine([\"./base\",\n        \"../compat\"],\nfunction(BaseSegmentation, compat) {\n  // SLIC segmentation.\n  function SLIC(imageData, options) {\n    BaseSegmentation.call(this, imageData, options);\n    options = options || {};\n    this.regionSize = options.regionSize || 16;\n    this.minRegionSize = options.minRegionSize ||\n                         Math.round(this.regionSize * 0.8);\n    this.maxIterations = options.maxIterations || 10;\n    this._compute();\n  }\n\n  SLIC.prototype = Object.create(BaseSegmentation.prototype);\n\n  SLIC.prototype.finer = function () {\n    var newSize = Math.max(5, Math.round(this.regionSize / Math.sqrt(2.0)));\n    if (newSize !== this.regionSize) {\n      this.regionSize = newSize;\n      this.minRegionSize = Math.round(newSize * 0.8);\n      this._compute();\n    }\n  };\n\n  SLIC.prototype.coarser = function () {\n    var newSize = Math.min(640, Math.round(this.regionSize * Math.sqrt(2.0)));\n    if (newSize !== this.regionSize) {\n      this.regionSize = newSize;\n      this.minRegionSize = Math.round(newSize * 0.8);\n      this._compute();\n    }\n  };\n\n  SLIC.prototype._compute = function () {\n    this.result = computeSLICSegmentation(this.imageData,\n                                          this.regionSize,\n                                          this.minRegionSize,\n                                          this.maxIterations);\n  };\n\n  // Convert RGBA into XYZ color space. rgba: Red Green Blue Alpha.\n  function rgb2xyz(rgba, w, h) {\n    var xyz = new Float32Array(3*w*h),\n        gamma = 2.2;\n    for (var i = 0; i<w*h; i++) {\n      // 1.0 / 255.9 = 0.00392156862.\n      var r = rgba[4*i+0] * 0.00392156862,\n          g = rgba[4*i+1] * 0.00392156862,\n          b = rgba[4*i+2] * 0.00392156862;\n      r = Math.pow(r, gamma);\n      g = Math.pow(g, gamma);\n      b = Math.pow(b, gamma);\n      xyz[i] = (r * 0.4887180 + g * 0.310680 + b * 0.2006020);\n      xyz[i + w*h] = (r * 0.1762040 + g * 0.812985 + b * 0.0108109);\n      xyz[i + 2*w*h] = (g * 0.0102048 + b * 0.989795);\n    }\n    return xyz;\n  }\n\n  // Convert XYZ to Lab.\n  function xyz2lab(xyz, w, h) {\n    function f(x) {\n      if (x > 0.00856)\n        return Math.pow(x, 0.33333333);\n      else\n        return 7.78706891568 * x + 0.1379310336;\n    }\n    var xw = 1.0 / 3.0,\n        yw = 1.0 / 3.0,\n        Yw = 1.0,\n        Xw = xw / yw,\n        Zw = (1-xw-yw) / (yw * Yw),\n        ix = 1.0 / Xw,\n        iy = 1.0 / Yw,\n        iz = 1.0 / Zw,\n        labData = new Float32Array(3*w*h);\n    for (var i = 0; i<w*h; i++) {\n      var fx = f(xyz[i] * ix),\n          fy = f(xyz[w*h + i] * iy),\n          fz = f(xyz[2*w*h + i] * iz);\n      labData[i] = 116.0 * fy - 16.0;\n      labData[i + w*h] = 500.0 * (fx - fy);\n      labData[i + 2*w*h] = 200.0 * (fy - fz);\n    }\n    return labData;\n  }\n\n  // Compute gradient of 3 channel color space image.\n  function computeEdge(image, edgeMap, w, h) {\n    for (var k = 0; k<3; k++) {\n      for (var y = 1; y<h-1; y++) {\n        for (var x = 1; x<w-1; x++) {\n          var a = image[k*w*h + y*w + x-1],\n              b = image[k*w*h + y*w + x+1],\n              c = image[k*w*h + (y+1)*w + x],\n              d = image[k*w*h + (y-1)*w + x];\n          edgeMap[y*w +x] += Math.pow(a-b, 2) + Math.pow(c-d, 2);\n        }\n      }\n    }\n  }\n\n  // Initialize superpixel clusters.\n  function initializeKmeansCenters(image,\n                                   edgeMap,\n                                   centers,\n                                   clusterParams,\n                                   numRegionsX,\n                                   numRegionsY,\n                                   regionSize,\n                                   imW,\n                                   imH) {\n    var i = 0,\n        j = 0,\n        x,\n        y;\n    for (var v = 0; v < numRegionsY; v++) {\n      for (var u = 0; u < numRegionsX; u++) {\n        var centerx = 0,\n            centery = 0,\n            minEdgeValue = Infinity,\n            xp,\n            yp;\n        x = parseInt(Math.round(regionSize * (u + 0.5)), 10);\n        y = parseInt(Math.round(regionSize * (v + 0.5)), 10);\n        x = Math.max(Math.min(x, imW-1),0);\n        y = Math.max(Math.min(y, imH-1),0);\n        // Search in a 3x3 neighbourhood the smallest edge response.\n        for (yp = Math.max(0, y-1); yp <= Math.min(imH-1, y+1); ++yp) {\n          for (xp = Math.max(0, x-1); xp <= Math.min(imW-1, x+1); ++xp) {\n            var thisEdgeValue = edgeMap[yp * imW + xp];\n            if (thisEdgeValue < minEdgeValue) {\n              minEdgeValue = thisEdgeValue;\n              centerx = xp;\n              centery = yp;\n            }\n          }\n        }\n\n        // Initialize the new center at this location.\n        centers[i++] = parseFloat(centerx);\n        centers[i++] = parseFloat(centery);\n        // 3 channels.\n        centers[i++] = image[centery * imW + centerx];\n        centers[i++] = image[imW * imH + centery * imW + centerx];\n        centers[i++] = image[2 * imW * imH + centery * imW + centerx];\n        // THIS IS THE VARIABLE VALUE OF M, just start with 5.\n        clusterParams[j++] = 10*10;\n        clusterParams[j++] = regionSize * regionSize;\n      }\n    }\n  }\n\n  // Re-compute clusters.\n  function computeCenters(image,\n                          segmentation,\n                          masses,\n                          centers,\n                          numRegions,\n                          imW,\n                          imH) {\n    var region;\n    for (var y = 0; y < imH; y++) {\n      for (var x = 0; x < imW; x++) {\n        region = segmentation[x + y * imW];\n        masses[region]++;\n        centers[region * 5 + 0] += x;\n        centers[region * 5 + 1] += y;\n        centers[region * 5 + 2] += image[y*imW + x];\n        centers[region * 5 + 3] += image[imW*imH + y*imW + x];\n        centers[region * 5 + 4] += image[2*imW*imH + y*imW + x];\n      }\n    }\n    for (region = 0; region < numRegions; region++) {\n      var iMass = 1.0 / Math.max(masses[region], 1e-8);\n      centers[region*5] = centers[region*5] * iMass;\n      centers[region*5+1] = centers[region*5+1] * iMass;\n      centers[region*5+2] = centers[region*5+2] * iMass;\n      centers[region*5+3] = centers[region*5+3] * iMass;\n      centers[region*5+4] = centers[region*5+4] * iMass;\n    }\n  }\n\n  // Remove small superpixels and assign them the nearest superpixel label.\n  function eliminateSmallRegions(segmentation,\n                                 minRegionSize,\n                                 numPixels,\n                                 imW,\n                                 imH) {\n    var cleaned = new Int32Array(numPixels),\n        segment = new Int32Array(numPixels),\n        dx = new Array(1, -1, 0, 0),\n        dy = new Array(0, 0, 1, -1),\n        segmentSize,\n        label,\n        cleanedLabel,\n        numExpanded,\n        pixel,\n        x,\n        y,\n        xp,\n        yp,\n        neighbor,\n        direction;\n    for (pixel = 0; pixel < numPixels; ++pixel) {\n      if (cleaned[pixel]) continue;\n      label = segmentation[pixel];\n      numExpanded = 0;\n      segmentSize = 0;\n      segment[segmentSize++] = pixel;\n      /** Find cleanedLabel as the label of an already cleaned region neighbor\n       * of this pixel.\n       */\n      cleanedLabel = label + 1;\n      cleaned[pixel] = label + 1;\n      x = (pixel % imW);\n      y = Math.floor(pixel / imW);\n      for (direction = 0; direction < 4; direction++) {\n        xp = x + dx[direction];\n        yp = y + dy[direction];\n        neighbor = xp + yp * imW;\n        if (0 <= xp && xp < imW && 0 <= yp && yp < imH && cleaned[neighbor])\n          cleanedLabel = cleaned[neighbor];\n      }\n      // Expand the segment.\n      while (numExpanded < segmentSize) {\n        var open = segment[numExpanded++];\n        x = open % imW;\n        y = Math.floor(open / imW);\n        for (direction = 0; direction < 4; ++direction) {\n          xp = x + dx[direction];\n          yp = y + dy[direction];\n          neighbor = xp + yp * imW;\n          if (0 <= xp &&\n              xp < imW &&\n              0 <= yp &&\n              yp < imH &&\n              cleaned[neighbor] === 0 &&\n              segmentation[neighbor] === label) {\n            cleaned[neighbor] = label + 1;\n            segment[segmentSize++] = neighbor;\n          }\n        }\n      }\n\n      // Change label to cleanedLabel if the semgent is too small.\n      if (segmentSize < minRegionSize) {\n        while (segmentSize > 0)\n          cleaned[segment[--segmentSize]] = cleanedLabel;\n      }\n    }\n    // Restore base 0 indexing of the regions.\n    for (pixel = 0; pixel < numPixels; ++pixel)\n      --cleaned[pixel];\n    for (var i =0; i < numPixels; ++i)\n      segmentation[i] = cleaned[i];\n  }\n\n  // Update cluster parameters.\n  function updateClusterParams(segmentation, mcMap, msMap, clusterParams) {\n    var mc = new Float32Array(clusterParams.length/2),\n        ms = new Float32Array(clusterParams.length/2);\n    for (var i = 0; i<segmentation.length; i++) {\n      var region = segmentation[i];\n      if (mc[region] < mcMap[region]) {\n        mc[region] = mcMap[region];\n        clusterParams[region*2+0] = mcMap[region];\n      }\n      if (ms[region] < msMap[region]) {\n        ms[region] = msMap[region];\n        clusterParams[region*2+1] = msMap[region];\n      }\n    }\n  }\n\n  // Assign superpixel label.\n  function assignSuperpixelLabel(im,\n                                 segmentation,\n                                 mcMap,\n                                 msMap,\n                                 distanceMap,\n                                 centers,\n                                 clusterParams,\n                                 numRegionsX,\n                                 numRegionsY,\n                                 regionSize,\n                                 imW,\n                                 imH) {\n    var x,\n        y;\n    for (var i = 0; i < distanceMap.length; ++i)\n      distanceMap[i] = Infinity;\n    var S = regionSize;\n    for (var region =0; region<numRegionsX * numRegionsY; ++region) {\n      var cx = Math.round(centers[region*5+0]),\n          cy = Math.round(centers[region*5+1]);\n      for (y = Math.max(0, cy - S);  y < Math.min(imH, cy + S); ++y) {\n        for (x = Math.max(0, cx - S); x < Math.min(imW, cx + S); ++x) {\n          var spatial = (x - cx) * (x - cx) + (y - cy) * (y - cy),\n              dR = im[y*imW + x] - centers[5*region + 2],\n              dG = im[imW * imH + y*imW + x] - centers[5*region + 3],\n              dB = im[2 * imW * imH + y*imW + x] - centers[5*region + 4],\n              appearance = dR * dR + dG * dG + dB * dB,\n              distance = Math.sqrt( appearance / clusterParams[region*2 + 0] +\n                         spatial / clusterParams[region*2 + 1]);\n          if (distance < distanceMap[y*imW + x]) {\n            distanceMap[y*imW + x] = distance;\n            segmentation[y*imW + x] = region;\n          }\n        }\n      }\n    }\n    // Update the max distance of color and space.\n    for (y = 0; y < imH; ++y) {\n      for (x = 0; x < imW; ++x) {\n        if (clusterParams[segmentation[y*imW + x]*2] < mcMap[y*imW + x])\n          clusterParams[segmentation[y*imW + x]*2] = mcMap[y*imW + x];\n        if (clusterParams[segmentation[y*imW + x]*2+1] < msMap[y*imW + x])\n          clusterParams[segmentation[y*imW + x]*2+1] = msMap[y*imW + x];\n      }\n    }\n  }\n\n  // ...\n  function computeResidualError(prevCenters, currentCenters) {\n    var error = 0.0;\n    for (var i = 0; i < prevCenters.length; ++i) {\n      var d = prevCenters[i] - currentCenters[i];\n      error += Math.sqrt(d*d);\n    }\n    return error;\n  }\n\n  // Remap label indices.\n  function remapLabels(segmentation) {\n    var map = {},\n        index = 0;\n    for (var i = 0; i < segmentation.length; ++i) {\n      var label = segmentation[i];\n      if (map[label] === undefined)\n        map[label] = index++;\n      segmentation[i] = map[label];\n    }\n    return index;\n  }\n\n  // Encode labels in RGB.\n  function encodeLabels(segmentation, data) {\n    for (var i = 0; i < segmentation.length; ++i) {\n      var value = Math.floor(segmentation[i]);\n      data[4 * i + 0] = value & 255;\n      data[4 * i + 1] = (value >>> 8) & 255;\n      data[4 * i + 2] = (value >>> 16) & 255;\n      data[4 * i + 3] = 255;\n    }\n  }\n\n  // Compute SLIC Segmentation.\n  function computeSLICSegmentation(imageData,\n                                   regionSize,\n                                   minRegionSize,\n                                   maxIterations) {\n    var i,\n        imWidth = imageData.width,\n        imHeight = imageData.height,\n        numRegionsX = Math.floor(imWidth / regionSize),\n        numRegionsY = Math.floor(imHeight / regionSize),\n        numRegions = Math.floor(numRegionsX * numRegionsY),\n        numPixels = Math.floor(imWidth * imHeight),\n        edgeMap = new Float32Array(numPixels),\n        masses = new Array(numPixels),\n        // 2 (geometric: x & y) and 3 (RGB or Lab)\n        currentCenters = new Float32Array((2+3)*numRegions),\n        newCenters = new Float32Array((2+3)*numRegions),\n        clusterParams = new Float32Array(2*numRegions),\n        mcMap = new Float32Array(numPixels),\n        msMap = new Float32Array(numPixels),\n        distanceMap = new Float32Array(numPixels),\n        xyzData = rgb2xyz(imageData.data, imWidth, imHeight),\n        labData = xyz2lab(xyzData, imWidth, imHeight);\n    // Compute edge.\n    computeEdge(labData, edgeMap, imWidth, imHeight);\n    // Initialize K-Means Centers.\n    initializeKmeansCenters(labData,\n                            edgeMap,\n                            currentCenters,\n                            clusterParams,\n                            numRegionsX,\n                            numRegionsY,\n                            regionSize,\n                            imWidth,\n                            imHeight);\n    var segmentation = new Int32Array(numPixels);\n    /** SLICO implementation: \"SLIC Superpixels Compared to State-of-the-art\n     * Superpixel Methods\"\n     */\n    for (var iter = 0; iter < maxIterations; ++iter) {\n      // Do assignment.\n      assignSuperpixelLabel(labData,\n                            segmentation,\n                            mcMap,\n                            msMap,\n                            distanceMap,\n                            currentCenters,\n                            clusterParams,\n                            numRegionsX,\n                            numRegionsY,\n                            regionSize,\n                            imWidth,\n                            imHeight);\n      // Update maximum spatial and color distances [1].\n      updateClusterParams(segmentation, mcMap, msMap, clusterParams);\n      // Compute new centers.\n      for (i = 0; i < masses.length; ++i)\n        masses[i] = 0;\n      for (i = 0; i < newCenters.length; ++i)\n        newCenters[i] = 0;\n      computeCenters(labData,\n                     segmentation,\n                     masses,\n                     newCenters,\n                     numRegions,\n                     imWidth,\n                     imHeight);\n      // Compute residual error of assignment.\n      var error = computeResidualError(currentCenters, newCenters);\n      if (error < 1e-5)\n        break;\n      for (i = 0; i < currentCenters.length; ++i)\n        currentCenters[i] = newCenters[i];\n    }\n    eliminateSmallRegions(segmentation,\n                          minRegionSize,\n                          numPixels,\n                          imWidth,\n                          imHeight);\n    // Refresh the canvas.\n    var result = compat.createImageData(imWidth, imHeight);\n    result.numSegments = remapLabels(segmentation);\n    encodeLabels(segmentation, result.data);\n    return result;\n  }\n\n  // function max(array) {\n  //   var value = array[0];\n  //   for (var i = 0; i < array.length; ++i)\n  //     value = Math.max(array[i], value);\n  //   return value;\n  // }\n\n  return SLIC;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/segmentation/slic.js\n// module id = 8\n// module chunks = 0","/** SLICO segmentation implementation.\n *\n *    SLIC Superpixels\n *    Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal\n *    Fua, and Sabine Süsstrunk\n *    IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 34,\n *    num. 11, p. 2274 - 2282, May 2012.\n *\n *  http://ivrl.epfl.ch/research/superpixels\n *\n * Copyright 2015  Kota Yamaguchi\n */\ndefine([\"./base\",\n        \"../compat\"],\nfunction(BaseSegmentation, compat) {\n  function SLICO(imageData, options) {\n    BaseSegmentation.call(this, imageData, options);\n    this.width  = this.imageData.width;\n    this.height = this.imageData.height;\n    options = options || {};\n    this.method = options.method || \"FixedK\";\n    this.perturb = (typeof options.perturb === \"undefined\") ?\n            true : options.perturb;\n    this.maxIterations = options.maxIterations || 10;\n    this.K = options.K || 1024;\n    this.step = options.step || 200;\n    this.enforceConnectivity = (options.enforceConnectivity === false) ?\n                                false : true;\n    this._compute();\n  }\n\n  SLICO.prototype = Object.create(BaseSegmentation.prototype);\n\n  SLICO.prototype.finer = function () {\n    var newK = Math.min(8962, Math.round(this.K * (2.0)));\n    if (newK !== this.K) {\n      this.K = newK;\n      this._compute();\n    }\n  };\n\n  SLICO.prototype.coarser = function () {\n    var newK = Math.max(16, Math.round(this.K / (2.0)));\n    if (newK !== this.K) {\n      this.K = newK;\n      this._compute();\n    }\n  };\n\n  SLICO.prototype._compute = function () {\n    var labels = (this.method === \"FixedK\") ?\n        this.performSLICOForGivenK() : this.performSLICOForGivenStepSize();\n    var result = new ImageData(this.width, this.height);\n    result.numSegments = remapLabels(labels);\n    encodeLabels(labels, result.data);\n    this.result = result;\n  };\n\n  // sRGB (D65 illuninant assumption) to XYZ conversion.\n  SLICO.prototype.rgb2xyz = function (sRGB) {\n    var R = parseInt(sRGB[0], 10) / 255.0,\n        G = parseInt(sRGB[1], 10) / 255.0,\n        B = parseInt(sRGB[2], 10) / 255.0,\n        r = (R <= 0.04045) ? R / 12.92 : Math.pow((R + 0.055) / 1.055, 2.4),\n        g = (G <= 0.04045) ? G / 12.92 : Math.pow((R + 0.055) / 1.055, 2.4),\n        b = (B <= 0.04045) ? B / 12.92 : Math.pow((R + 0.055) / 1.055, 2.4);\n    return [\n      r * 0.4124564 + g * 0.3575761 + b * 0.1804375,\n      r * 0.2126729 + g * 0.7151522 + b * 0.0721750,\n      r * 0.0193339 + g * 0.1191920 + b * 0.9503041\n    ];\n  };\n\n  // sRGB to Lab conversion.\n  SLICO.prototype.rgb2lab = function (sRGB) {\n    var epsilon = 0.008856,  //actual CIE standard\n        kappa   = 903.3,     //actual CIE standard\n        Xr = 0.950456,       //reference white\n        Yr = 1.0,            //reference white\n        Zr = 1.088754,       //reference white\n        xyz = this.rgb2xyz(sRGB),\n        xr = xyz[0] / Xr,\n        yr = xyz[1] / Yr,\n        zr = xyz[2] / Zr,\n        fx = (xr > epsilon) ?\n            Math.pow(xr, 1.0/3.0) : (kappa * xr + 16.0) / 116.0,\n        fy = (yr > epsilon) ?\n            Math.pow(yr, 1.0/3.0) : (kappa * yr + 16.0) / 116.0,\n        fz = (zr > epsilon) ?\n            Math.pow(zr, 1.0/3.0) : (kappa * zr + 16.0) / 116.0;\n    return [\n      116.0 * fy - 16.0,\n      500.0 * (fx - fy),\n      200.0 * (fy - fz)\n    ];\n  };\n\n  SLICO.prototype.doRGBtoLABConversion = function (imageData) {\n    var size = this.width * this.height,\n        data = imageData.data;\n    this.lvec = new Float64Array(size);\n    this.avec = new Float64Array(size);\n    this.bvec = new Float64Array(size);\n    for (var j = 0; j < size; ++j) {\n      var r = data[4 * j + 0],\n          g = data[4 * j + 1],\n          b = data[4 * j + 2];\n      var lab = this.rgb2lab([r, g, b]);\n      this.lvec[j] = lab[0];\n      this.avec[j] = lab[1];\n      this.bvec[j] = lab[2];\n    }\n  };\n\n  SLICO.prototype.detectLabEdges = function () {\n    var w = this.width;\n    this.edges = fillArray(new Float64Array(this.width * this.height), 0);\n    for (var j = 1; j < this.height - 1; ++j) {\n      for (var k = 1; k < this.width - 1; ++k) {\n        var i = parseInt(j * this.width + k, 10),\n            dx = Math.pow(this.lvec[i - 1] - this.lvec[i + 1], 2) +\n                 Math.pow(this.avec[i - 1] - this.avec[i + 1], 2) +\n                 Math.pow(this.bvec[i - 1] - this.bvec[i + 1], 2),\n            dy = Math.pow(this.lvec[i - w] - this.lvec[i + w], 2) +\n                 Math.pow(this.avec[i - w] - this.avec[i + w], 2) +\n                 Math.pow(this.bvec[i - w] - this.bvec[i + w], 2);\n        this.edges[i] = dx + dy;\n      }\n    }\n  };\n\n  SLICO.prototype.perturbSeeds = function () {\n    var dx8 = [-1, -1,  0,  1, 1, 1, 0, -1],\n        dy8 = [ 0, -1, -1, -1, 0, 1, 1,  1],\n        numSeeds = this.kSeedsL.length;\n    for (var n = 0; n < numSeeds; ++n) {\n      var ox = parseInt(this.kSeedsX[n], 10),  //original x\n          oy = parseInt(this.kSeedsY[n], 10),  //original y\n          oind = parseInt(oy * this.width + ox, 10),\n          storeind = parseInt(oind, 10);\n      for (var i = 0; i < 8; ++i) {\n        var nx = parseInt(ox + dx8[i], 10);  //new x\n        var ny = parseInt(oy + dy8[i], 10);  //new y\n        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {\n          var nind = parseInt(ny * this.width + nx, 10);\n          if (this.edges[nind] < this.edges[storeind])\n            storeind = nind;\n        }\n      }\n      if (storeind != oind) {\n        this.kSeedsX[n] = Math.floor(storeind % this.width);\n        this.kSeedsY[n] = Math.floor(storeind / this.width);\n        this.kSeedsL[n] = this.lvec[storeind];\n        this.kSeedsA[n] = this.avec[storeind];\n        this.kSeedsB[n] = this.bvec[storeind];\n      }\n    }\n  };\n\n  SLICO.prototype.getLABXYSeedsForGivenStepSize = function(step, perturb) {\n    var n = 0,\n        xstrips = Math.round(0.5 + parseFloat(this.width) / parseFloat(step)),\n        ystrips = Math.round(0.5 + parseFloat(this.height) / parseFloat(step)),\n        xerr = Math.round(this.width  - step * xstrips),\n        yerr = Math.round(this.height - step * ystrips),\n        xerrperstrip = parseFloat(xerr) / parseFloat(xstrips),\n        yerrperstrip = parseFloat(yerr) / parseFloat(ystrips),\n        xoff = Math.floor(step / 2),\n        yoff = Math.floor(step / 2),\n        numSeeds = xstrips * ystrips;\n    this.kSeedsL = new Float64Array(numSeeds);\n    this.kSeedsA = new Float64Array(numSeeds);\n    this.kSeedsB = new Float64Array(numSeeds);\n    this.kSeedsX = new Float64Array(numSeeds);\n    this.kSeedsY = new Float64Array(numSeeds);\n    for (var y = 0; y < ystrips; ++y) {\n      var ye = Math.floor(y * yerrperstrip);\n      for (var x = 0; x < xstrips; ++x) {\n        var xe = Math.floor(x * xerrperstrip);\n        var i = Math.floor((y * step + yoff + ye) * this.width +\n                           (x * step + xoff + xe));\n        this.kSeedsL[n] = this.lvec[i];\n        this.kSeedsA[n] = this.avec[i];\n        this.kSeedsB[n] = this.bvec[i];\n        this.kSeedsX[n] = (x * step + xoff + xe);\n        this.kSeedsY[n] = (y * step + yoff + ye);\n        ++n;\n      }\n    }\n    if (perturb)\n      this.perturbSeeds();\n  };\n\n  SLICO.prototype.getLABXYSeedsForGivenK = function(K, perturb) {\n    var size = Math.floor(this.width * this.height);\n    var step = Math.sqrt(parseFloat(size) / parseFloat(K));\n    var xoff = Math.round(step / 2);\n    var yoff = Math.round(step / 2);\n    var n = 0;\n    var r = 0;\n    this.kSeedsL = [];\n    this.kSeedsA = [];\n    this.kSeedsB = [];\n    this.kSeedsX = [];\n    this.kSeedsY = [];\n    for (var y = 0; y < this.height; ++y) {\n      var Y = Math.floor(y * step + yoff);\n      if (Y > this.height - 1)\n        break;\n      for (var x = 0; x < this.width; ++x) {\n        //var X = x*step + xoff;  //square grid\n        var X = Math.floor(x * step + (xoff << (r & 0x1)));  //hex grid\n        if (X > this.width - 1)\n          break;\n        var i = Math.floor(Y * this.width + X);\n        this.kSeedsL.push(this.lvec[i]);\n        this.kSeedsA.push(this.avec[i]);\n        this.kSeedsB.push(this.bvec[i]);\n        this.kSeedsX.push(X);\n        this.kSeedsY.push(Y);\n        ++n;\n      }\n      ++r;\n    }\n    if (perturb)\n      this.perturbSeeds();\n  };\n\n  function fillArray(array, value) {\n    for (var i = 0; i < array.length; ++i)\n      array[i] = value;\n    return array;\n  }\n\n  // function findMinMax(data) {\n  //   var min = Infinity, max = -Infinity;\n  //   for (var i = 0; i < data.length; ++i) {\n  //     min = Math.min(min, data[i]);\n  //     max = Math.max(max, data[i]);\n  //   }\n  //   return [min, max];\n  // }\n\n  // function sum(data) {\n  //   var value = 0;\n  //   for (var i = 0; i < data.length; ++i)\n  //     value += data[i];\n  //   return value;\n  // }\n\n  SLICO.prototype.performSuperpixelSegmentationVariableSandM = function (\n    kLabels,\n    step,\n    maxIterations\n    ) {\n    var size = Math.floor(this.width * this.height),\n        numK = this.kSeedsL.length,\n        numIter = 0,\n        offset = Math.floor((step < 10) ? step * 1.5 : step),\n        sigmal = fillArray(new Float64Array(numK), 0),\n        sigmaa = fillArray(new Float64Array(numK), 0),\n        sigmab = fillArray(new Float64Array(numK), 0),\n        sigmax = fillArray(new Float64Array(numK), 0),\n        sigmay = fillArray(new Float64Array(numK), 0),\n        clusterSize = fillArray(new Int32Array(numK), 0),\n        distxy = fillArray(new Float64Array(size), Infinity),\n        distlab = fillArray(new Float64Array(size), Infinity),\n        distvec = fillArray(new Float64Array(size), Infinity),\n        maxlab = fillArray(new Float64Array(numK), Math.pow(10, 2)),\n        maxxy = fillArray(new Float64Array(numK), Math.pow(step, 2)),\n        i, j, k, n, x, y;\n    while (numIter < maxIterations) {\n      ++numIter;\n      // Assign the closest cluster.\n      fillArray(distvec, Infinity);\n      for (n = 0; n < numK; ++n) {\n        var y1 = Math.floor(Math.max(0, this.kSeedsY[n] - offset)),\n            y2 = Math.floor(Math.min(this.height, this.kSeedsY[n] + offset)),\n            x1 = Math.floor(Math.max(0, this.kSeedsX[n] - offset)),\n            x2 = Math.floor(Math.min(this.width, this.kSeedsX[n] + offset));\n        for (y = y1; y < y2; ++y) {\n          for (x = x1; x < x2; ++x) {\n            i = Math.floor(y * this.width + x);\n            if (!(y < this.height && x < this.width && y >= 0 && x >= 0))\n              throw \"Assertion error\";\n            var l = this.lvec[i],\n                a = this.avec[i],\n                b = this.bvec[i];\n            distlab[i] = Math.pow(l - this.kSeedsL[n], 2) +\n                         Math.pow(a - this.kSeedsA[n], 2) +\n                         Math.pow(b - this.kSeedsB[n], 2);\n            distxy[i] = Math.pow(x - this.kSeedsX[n], 2) +\n                        Math.pow(y - this.kSeedsY[n], 2);\n            var dist = distlab[i] / maxlab[n] + distxy[i] / maxxy[n];\n            if (dist < distvec[i]) {\n              distvec[i] = dist;\n              kLabels[i] = n;\n            }\n          }\n        }\n      }\n      //console.log(\"iter = \" + numIter + \", sum_dist = \" + sum(distvec));\n      // Assign the max color distance for a cluster.\n      if (numIter === 0) {\n        fillArray(maxlab, 1);\n        fillArray(maxxy, 1);\n      }\n      for (i = 0; i < size; ++i) {\n        if (maxlab[kLabels[i]] < distlab[i])\n          maxlab[kLabels[i]] = distlab[i];\n        if (maxxy[kLabels[i]] < distxy[i])\n          maxxy[kLabels[i]] = distxy[i];\n      }\n      // Recalculate the centroid and store in the seed values.\n      fillArray(sigmal, 0);\n      fillArray(sigmaa, 0);\n      fillArray(sigmab, 0);\n      fillArray(sigmax, 0);\n      fillArray(sigmay, 0);\n      fillArray(clusterSize, 0);\n      for (j = 0; j < size; ++j) {\n        var temp = kLabels[j];\n        if (temp < 0)\n          throw \"Assertion error\";\n        sigmal[temp] += this.lvec[j];\n        sigmaa[temp] += this.avec[j];\n        sigmab[temp] += this.bvec[j];\n        sigmax[temp] += (j % this.width);\n        sigmay[temp] += (j / this.width);\n        clusterSize[temp]++;\n      }\n      for (k = 0; k < numK; ++k) {\n        if (clusterSize[k] <= 0)\n          clusterSize[k] = 1;\n        //computing inverse now to multiply, than divide later.\n        var inv = 1.0 / clusterSize[k];\n        this.kSeedsL[k] = sigmal[k] * inv;\n        this.kSeedsA[k] = sigmaa[k] * inv;\n        this.kSeedsB[k] = sigmab[k] * inv;\n        this.kSeedsX[k] = sigmax[k] * inv;\n        this.kSeedsY[k] = sigmay[k] * inv;\n      }\n    }\n  };\n\n  SLICO.prototype.enforceLabelConnectivity = function (labels, nlabels, K) {\n    var dx4 = [-1,  0,  1,  0],\n        dy4 = [ 0, -1,  0,  1],\n        size = this.width * this.height,\n        SUPSZ = Math.floor(size / K),\n        c, n, x, y, nindex;\n    var label = 0,\n        xvec = new Int32Array(size),\n        yvec = new Int32Array(size),\n        oindex = 0,\n        adjlabel = 0;  // adjacent label\n    for (var j = 0; j < this.height; ++j) {\n      for (var k = 0; k < this.width; ++k) {\n        if (nlabels[oindex] < 0) {\n          nlabels[oindex] = label;\n          // Start a new segment.\n          xvec[0] = k;\n          yvec[0] = j;\n          //  Quickly find an adjacent label for use later if needed.\n          for (n = 0; n < 4; ++n) {\n            x = Math.floor(xvec[0] + dx4[n]);\n            y = Math.floor(yvec[0] + dy4[n]);\n            if ((x >= 0 && x < this.width) && (y >= 0 && y < this.height)) {\n              nindex = Math.floor(y * this.width + x);\n              if (nlabels[nindex] >= 0)\n                adjlabel = nlabels[nindex];\n            }\n          }\n          var count = 1;\n          for (c = 0; c < count; ++c) {\n            for (n = 0; n < 4; ++n) {\n              x = Math.floor(xvec[c] + dx4[n]);\n              y = Math.floor(yvec[c] + dy4[n]);\n              if ((x >= 0 && x < this.width) && (y >= 0 && y < this.height)) {\n                nindex = Math.floor(y * this.width + x);\n                if (nlabels[nindex] < 0 && labels[oindex] == labels[nindex]) {\n                  xvec[count] = x;\n                  yvec[count] = y;\n                  nlabels[nindex] = label;\n                  ++count;\n                }\n              }\n            }\n          }\n          // If segment size is less then a limit, assign an\n          // adjacent label found before, and decrement label count.\n          if (count <= SUPSZ >> 2) {\n            for (c = 0; c < count; c++ ) {\n              var ind = Math.floor(yvec[c] * this.width + xvec[c]);\n              nlabels[ind] = adjlabel;\n            }\n            --label;\n          }\n          ++label;\n        }\n        ++oindex;\n      }\n    }\n    return label;\n  };\n\n  SLICO.prototype.performSLICOForGivenStepSize = function() {\n    var size = this.width * this.height,\n        kLabels = fillArray(new Int32Array(size), -1);\n    this.doRGBtoLABConversion(this.imageData);\n    if (this.perturb)\n      this.detectLabEdges();\n    this.getLABXYSeedsForGivenStepSize(this.step, this.perturb);\n    this.performSuperpixelSegmentationVariableSandM(kLabels,\n                                                    this.step,\n                                                    this.maxIterations);\n    var numlabels = kLabels.length;\n    if (this.enforceConnectivity) {\n      var nlabels = fillArray(new Int32Array(size), -1);\n      numlabels = this.enforceLabelConnectivity(kLabels,\n                                                nlabels,\n                                                size / (this.step * this.estep));\n      for (var i = 0; i < size; ++i)\n        kLabels[i] = nlabels[i];\n    }\n    return kLabels;\n  };\n\n  SLICO.prototype.performSLICOForGivenK = function() {\n    var size = this.width * this.height,\n        kLabels = fillArray(new Int32Array(size), -1);\n    this.doRGBtoLABConversion(this.imageData);\n    if (this.perturb)\n      this.detectLabEdges();\n    this.getLABXYSeedsForGivenK(this.K, this.perturb);\n    var step = Math.sqrt(size / this.K) + 2.0;\n    this.performSuperpixelSegmentationVariableSandM(kLabels,\n                                                    step,\n                                                    this.maxIterations);\n    var numlabels = kLabels.length;\n    if (this.enforceConnectivity) {\n      var nlabels = fillArray(new Int32Array(size), -1);\n      numlabels = this.enforceLabelConnectivity(kLabels, nlabels, this.K);\n      for (var i = 0; i < size; ++i)\n        kLabels[i] = nlabels[i];\n    }\n    return kLabels;\n  };\n\n  SLICO.prototype.drawContoursAroundSegments = function (result) {\n    var imageData = new ImageData(this.width, this.height),\n        data = fillArray(imageData.data, 255),\n        color = [255, 0, 0],\n        dx8 = [-1, -1,  0,  1, 1, 1, 0, -1],\n        dy8 = [ 0, -1, -1, -1, 0, 1, 1,  1],\n        istaken = fillArray(new Uint8Array(this.width * this.height), 0);\n    var mainindex = 0;\n    for (var j = 0; j < this.height; ++j) {\n      for (var k = 0; k < this.width; ++k) {\n        var np = 0;\n        for (var i = 0; i < 8; ++i) {\n          var x = k + dx8[i],\n              y = j + dy8[i];\n          if ((x >= 0 && x < this.width) && (y >= 0 && y < this.height)) {\n            var index = y * this.width + x;\n            if (istaken[index] === 0 &&\n                result.labels[mainindex] !== result.labels[index])\n              ++np;\n          }\n        }\n        if (np > 1) {\n          data[4 * mainindex + 0] = color[0];\n          data[4 * mainindex + 1] = color[1];\n          data[4 * mainindex + 2] = color[2];\n        }\n        ++mainindex;\n      }\n    }\n    return imageData;\n  };\n\n  // Remap label indices.\n  function remapLabels(labels) {\n    var map = {},\n        index = 0;\n    for (var i = 0; i < labels.length; ++i) {\n      var label = labels[i];\n      if (map[label] === undefined)\n        map[label] = index++;\n        labels[i] = map[label];\n    }\n    return index;\n  }\n\n  function encodeLabels(labels, data) {\n    for (var i = 0; i < labels.length; ++i) {\n      var label = labels[i];\n      data[4 * i + 0] = 255 & label;\n      data[4 * i + 1] = 255 & (label >> 8);\n      data[4 * i + 2] = 255 & (label >> 16);\n      data[4 * i + 3] = 255;\n    }\n  }\n\n  return SLICO;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/segmentation/slico.js\n// module id = 9\n// module chunks = 0","/**\n * Canny + Watershed segmentation algorithm.\n *\n *  var segmentation = new WatershedSegmentation(imageData);\n *  var result = segmentation.result;\n *  var result = segmentation.finer();\n *  var result = segmentation.coarser();\n *\n *  TODO:\n *  * Edge options other than canny.\n *  * Create a graph-structure for coarse/fine adjustment.\n *\n */\ndefine([\"./base\",\n        \"./binary-heap-priority-queue\",\n        \"../canny\",\n        \"../compat\",\n        \"../distance-transform\"],\nfunction (BaseSegmentation, PriorityQueue, canny, compat, distanceTransform) {\n  // Constructor for the segmentation configuration.\n  function WatershedSegmentation(imageData, options) {\n    BaseSegmentation.call(this, imageData, options);\n    options = options || {};\n    this.sigmaRange = options.sigmaRange ||\n      [-2, -1, 0, 0.5, 1, 2, 3].map(function(n){\n        return Math.pow(2, n);\n      });\n    this.kernelRange = options.kernelRange || [2, 3, 4, 4, 4, 5, 6];\n    this.currentConfig = options.currentConfig ||\n                         Math.floor((this.sigmaRange.length - 1) / 2);\n    this.minRegionSize = options.minRegionSize || 16;\n    this.highThreshold = options.highThreshold || 0.04;\n    this.lowThreshold = options.lowThreshold || 0.3 * options.highThreshold;\n    if (this.sigmaRange.length <= 0)\n      throw \"Invalid sigma range\";\n    this.neighborMap8 = new NeighborMap(this.imageData.width,\n                                        this.imageData.height);\n    this.neighborMap4 = new NeighborMap(this.imageData.width,\n                                        this.imageData.height,\n                                        [[-1, -1],\n                                         [-1, 0],\n                                         [-1, 1],\n                                         [ 0, -1]]);\n    this._compute();\n  }\n\n  WatershedSegmentation.prototype = Object.create(BaseSegmentation.prototype);\n\n  // Change the segmentation resolution.\n  WatershedSegmentation.prototype.finer = function () {\n    if (this.currentConfig > 0) {\n      --this.currentConfig;\n      if (this.imageData)\n        this._compute();\n    }\n  };\n\n  // Change the segmentation resolution.\n  WatershedSegmentation.prototype.coarser = function () {\n    if (this.currentConfig < this.sigmaRange.length - 1) {\n      ++this.currentConfig;\n      if (this.imageData)\n        this._compute();\n    }\n  };\n\n  // Compute canny-watershed segmentation.\n  WatershedSegmentation.prototype._compute = function () {\n    var queue = new PriorityQueue({\n      comparator: function(a, b) { return a[0] - b[0]; }\n    });\n    var edge = canny(this.imageData, {\n      kernelTail: this.kernelRange[this.currentConfig],\n      sigma: this.sigmaRange[this.currentConfig],\n      lowThreshold: this.lowThreshold,\n      highThreshold: this.highThreshold\n    });\n    var seeds = this._findLocalMaxima(distanceTransform(edge));\n    var labels = new Int32Array(edge.data.length);\n    var i, j, offset, neighbors, neighborOffset;\n    // Initialize.\n    for (i = 0; i < labels.length; ++i)\n      labels[i] = -1;\n    for (i = 0; i < seeds.length; ++i)\n      labels[seeds[i]] = i + 1;\n    for (i = 0; i < seeds.length; ++i) {\n      neighbors = this.neighborMap8.get(seeds[i]);\n      for (j = 0; j < neighbors.length; ++j) {\n        neighborOffset = neighbors[j];\n        if (labels[neighborOffset] === -1) {\n          queue.push([edge.magnitude[neighborOffset], neighborOffset]);\n          labels[neighborOffset] = -2;\n        }\n      }\n    }\n    // Iterate until we label all pixels by non-border dilation.\n    var iter = 0;\n    while (queue.length > 0) {\n      offset = queue.shift()[1];\n      neighbors = this.neighborMap8.get(offset);\n      var uniqueLabel = this._findUniqueRegionLabel(neighbors, labels);\n      if (uniqueLabel) {  // Dilate when there is a unique region label.\n        labels[offset] = uniqueLabel;\n        for (i = 0; i < neighbors.length; ++i) {\n          neighborOffset = neighbors[i];\n          if (labels[neighborOffset] === -1) {\n            labels[neighborOffset] = -2;\n            queue.push([edge.magnitude[neighborOffset], neighborOffset]);\n          }\n        }\n      }\n      else\n        labels[offset] = 0;  // Boundary.\n      if (++iter > labels.length)\n        throw \"Too many iterations\";\n    }\n    // Remove boundaries and small regions.\n    this.erode(0, labels);\n    this._removeSmallRegions(labels);\n    var numSegments = this._relabel(labels);\n    this.result = this._encodeLabels(labels);\n    this.result.numSegments = numSegments;\n  };\n\n  // Find the local maxima.\n  WatershedSegmentation.prototype._findLocalMaxima = function (intensity) {\n    var data = intensity.data,\n        maximaMap = new Uint8Array(data.length),\n        offsets = [],\n        k, offset, neighbors, flag;\n    for (offset = 0; offset < data.length; ++offset) {\n      neighbors = this.neighborMap8.get(offset);\n      flag = true;\n      for (k = 0; k < neighbors.length; ++k)\n        flag = flag && data[offset] >= data[neighbors[k]];\n      maximaMap[offset] = flag;\n    }\n    // Erase connected seeds.\n    var suppressed = new Uint8Array(maximaMap.length);\n    for (offset = 0; offset < data.length; ++offset) {\n      neighbors = this.neighborMap4.get(offset);\n      flag = true;\n      for (k = 0; k < neighbors.length; ++k)\n        flag = flag && maximaMap[offset] > maximaMap[neighbors[k]];\n      suppressed[offset] = flag;\n    }\n    for (offset = 0; offset < suppressed.length; ++offset)\n      if (suppressed[offset])\n        offsets.push(offset);\n    return offsets;\n  };\n\n  WatershedSegmentation.prototype._findUniqueRegionLabel =\n      function (neighbors, labels) {\n    var uniqueLabels = [];\n    for (var i = 0; i < neighbors.length; ++i) {\n      var label = labels[neighbors[i]];\n      if (label > 0 && uniqueLabels.indexOf(label) < 0)\n        uniqueLabels.push(label);\n    }\n    return (uniqueLabels.length === 1) ? uniqueLabels[0] : null;\n  };\n\n  WatershedSegmentation.prototype._findDominantLabel =\n      function (neighbors, labels, target) {\n    var histogram = {},\n        label;\n    for (var i = 0; i < neighbors.length; ++i) {\n      label = labels[neighbors[i]];\n      if (label !== target) {\n        if (histogram[label])\n          ++histogram[label];\n        else\n          histogram[label] = 1;\n      }\n    }\n    var count = 0,\n        dominantLabel = null;\n    for (label in histogram) {\n      if (histogram[label] > count) {\n        dominantLabel = label;\n        count = histogram[label];\n      }\n    }\n    return dominantLabel;\n  };\n\n  // Greedy erode.\n  WatershedSegmentation.prototype.erode = function (target, labels) {\n    var offsets = [],\n        updates = {},\n        offset;\n    for (offset = 0; offset < labels.length; ++offset)\n      if (labels[offset] === target)\n        offsets.push(offset);\n    if (target !== 0 && offsets.length === 0)\n      throw \"No pixels for label \" + target;\n    updates[target] = 0;\n    var iter = 0;\n    while (offsets.length > 0) {\n      offset = offsets.shift();\n      var neighbors = this.neighborMap8.get(offset),\n          dominantLabel = this._findDominantLabel(neighbors, labels, target);\n      if (dominantLabel !== null) {\n        labels[offset] = dominantLabel;\n        if (updates[dominantLabel])\n          ++updates[dominantLabel];\n        else\n          updates[dominantLabel] = 1;\n        --updates[target];\n      }\n      else\n        offsets.push(offset);\n      if (++iter > labels.length)\n        throw \"Too many iterations for label \" + target;\n    }\n    return updates;\n  };\n\n  // Find small item.\n  WatershedSegmentation.prototype._findSmallLabel =\n      function (histogram) {\n    var smallLabel = null;\n    for (var label in histogram) {\n      var count = histogram[label];\n      if (0 < count && count < this.minRegionSize) {\n        smallLabel = parseInt(label, 10);\n        break;\n      }\n    }\n    return smallLabel;\n  };\n\n  // Remove small regions.\n  WatershedSegmentation.prototype._removeSmallRegions =\n      function (labels) {\n    var histogram = {},\n        offset, label, updates;\n    for (offset = 0; offset < labels.length; ++offset) {\n      label = labels[offset];\n      if (histogram[label])\n        ++histogram[label];\n      else\n        histogram[label] = 1;\n    }\n    var iter = 0;\n    while (true) {\n      var smallLabel = this._findSmallLabel(histogram);\n      if (smallLabel !== null) {\n        updates = this.erode(smallLabel, labels);\n        for (label in updates)\n          histogram[label] += updates[label];\n      }\n      else\n        break;\n      if (++iter >= Object.keys(histogram).length)\n        throw \"Too many iterations\";\n    }\n  };\n\n  WatershedSegmentation.prototype._relabel = function (labels) {\n    var uniqueArray = [];\n    for (var i = 0; i < labels.length; ++i) {\n      var index = uniqueArray.indexOf(labels[i]);\n      if (index < 0) {\n        index = uniqueArray.length;\n        uniqueArray.push(labels[i]);\n      }\n      labels[i] = index;\n    }\n    return uniqueArray.length;\n  };\n\n  // Encode segmentation.\n  WatershedSegmentation.prototype._encodeLabels = function (labels) {\n    var imageData = new ImageData(this.imageData.width,\n                                  this.imageData.height),\n        data = imageData.data;\n    for (var i = 0; i < labels.length; ++i) {\n      var value = labels[i];\n      data[4 * i] = 255 & value;\n      data[4 * i + 1] = 255 & (value >> 8);\n      data[4 * i + 2] = 255 & (value >> 16);\n      data[4 * i + 3] = 255;\n    }\n    return imageData;\n  };\n\n  // Neighbor Map.\n  function NeighborMap(width, height, neighbors) {\n    this.neighbors = neighbors || [[-1, -1], [-1, 0], [-1, 1],\n                                   [ 0, -1],          [ 0, 1],\n                                   [ 1, -1], [ 1, 0], [ 1, 1]];\n    this.maps = [];\n    for (var k = 0; k < this.neighbors.length; ++k) {\n      var dy = this.neighbors[k][0],\n          dx = this.neighbors[k][1],\n          map = new Int32Array(width * height);\n      for (var y = 0; y < height; ++y) {\n        for (var x = 0; x < width; ++x) {\n          var Y = y + dy,\n              X = x + dx;\n          map[y * width + x] = (Y < 0 || height <= Y || X < 0 || width <= X) ?\n                               -1 : Y * width + X;\n        }\n      }\n      this.maps.push(map);\n    }\n  }\n\n  NeighborMap.prototype.get = function (offset) {\n    var neighborOffsets = [];\n    for (var k = 0; k < this.neighbors.length; ++k) {\n      var neighborOffset = this.maps[k][offset];\n      if (neighborOffset >= 0)\n        neighborOffsets.push(neighborOffset);\n    }\n    return neighborOffsets;\n  };\n\n\n  return WatershedSegmentation;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/segmentation/watershed.js\n// module id = 10\n// module chunks = 0","/** Priority queue based on binary heap.\n *\n * Example: Basic usage.\n *\n *    var queue = new PriorityQueue();\n *    queue.push(1);\n *    queue.push(2);\n *    queue.push(0);\n *    var x = queue.shift();  // returns 0\n *\n * Example: By descending order.\n *\n *    var queue = new PriorityQueue({\n *      comparator: function (a, b) { return b - a; }\n *    });\n *\n * Copyright 2015  Kota Yamaguchi\n */\ndefine([], function () {\n  function BinaryHeapPriorityQueue(options) {\n    options = options || {};\n    this.comparator = options.comparator || function (a, b) { return a - b; };\n    this.data = (options.initialValues) ? options.initialValues.slice(0) : [];\n    this.length = this.data.length;\n    if (this.data.length > 0)\n      for (var i = 1; i <= this.data.length; ++i)\n        this._bubbleUp(i);\n  }\n\n  BinaryHeapPriorityQueue.prototype.push = function (value) {\n    this.data.push(value);\n    this.length = this.data.length;\n    this._bubbleUp(this.data.length - 1);\n    return this;\n  };\n\n  BinaryHeapPriorityQueue.prototype.shift = function () {\n    var value = this.data[0],\n        last = this.data.pop();\n    this.length = this.data.length;\n    if (this.length > 0) {\n      this.data[0] = last;\n      this._bubbleDown(0);\n    }\n    return value;\n  };\n\n  BinaryHeapPriorityQueue.prototype.peek = function () {\n    return this.data[0];\n  };\n\n  BinaryHeapPriorityQueue.prototype._bubbleUp = function (i) {\n    while (i > 0) {\n      var parent = (i - 1) >>> 1;\n      if (this.comparator(this.data[i], this.data[parent]) < 0) {\n        var value = this.data[parent];\n        this.data[parent] = this.data[i];\n        this.data[i] = value;\n        i = parent;\n      }\n      else\n        break;\n    }\n  };\n\n  BinaryHeapPriorityQueue.prototype._bubbleDown = function (i) {\n    var last = this.data.length - 1;\n    while (true) {\n      var left = (i << 1) + 1,\n          right = left + 1,\n          minIndex = i;\n      if (left <= last &&\n          this.comparator(this.data[left], this.data[minIndex]) < 0)\n        minIndex = left;\n      if (right <= last &&\n          this.comparator(this.data[right], this.data[minIndex]) < 0)\n        minIndex = right;\n      if (minIndex !== i) {\n        var value = this.data[minIndex];\n        this.data[minIndex] = this.data[i];\n        this.data[i] = value;\n        i = minIndex;\n      }\n      else\n        break;\n    }\n  };\n\n  return BinaryHeapPriorityQueue;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/segmentation/binary-heap-priority-queue.js\n// module id = 11\n// module chunks = 0","/** Canny edge detection.\n *\n *  var edge = canny(imageData, {});\n *\n * Copyright 2015  Kota Yamaguchi\n */\n'use strict';\nfunction createIntensityData(width, height) {\n  return {\n    width: width,\n    height: height,\n    data: new Float32Array(width * height)\n  };\n}\n\nfunction createGaussian1D(k, sigma) {\n  k = k || 1;\n  sigma = sigma || 1.3;\n  var size = 2 * k + 1,\n    kernel = new Float32Array(size),\n    coeff = 1 / (2 * Math.PI * Math.pow(sigma, 2));\n  for (var i = 0; i < size; ++i)\n    kernel[i] = coeff * Math.exp(-Math.pow((i - k) / sigma, 2));\n  return normalize(kernel);\n}\n\nfunction normalize(array) {\n  var sum = 0,\n    i;\n  for (i = 0; i < array.length; ++i)\n    sum += array[i];\n  for (i = 0; i < array.length; ++i)\n    array[i] /= sum;\n  return array;\n}\n\nfunction rgb2intensity(imageData) {\n  var intensity = createIntensityData(imageData.width, imageData.height),\n    newData = intensity.data,\n    data = imageData.data;\n  for (var i = 0; i < imageData.width * imageData.height; ++i) {\n    newData[i] = (data[4 * i] + data[4 * i + 1] + data[4 * i + 2]) /\n      (3 * 255);\n  }\n  return intensity;\n}\n\nfunction padImage(intensity, size) {\n  size = size || [0, 0];\n  if (typeof size === \"number\")\n    size = [size, size];\n  var width = intensity.width,\n    height = intensity.height,\n    data = intensity.data,\n    newIntensity = createIntensityData(width + 2 * size[0],\n      height + 2 * size[1]),\n    newData = newIntensity.data,\n    i, j;\n  for (i = 0; i < newIntensity.height; ++i) {\n    var y = (i < size[1]) ? size[1] - i :\n      (i >= height + size[1]) ? 2 * height - size[1] + 1 - i :\n        i - size[1];\n    for (j = 0; j < newIntensity.width; ++j) {\n      var x = (j < size[0]) ? size[0] - j :\n        (j >= width + size[0]) ? 2 * width - size[0] + 1 - j :\n          j - size[0],\n        newOffset = i * newIntensity.width + j,\n        oldOffset = y * width + x;\n      newData[newOffset] = data[oldOffset];\n    }\n  }\n  return newIntensity;\n}\n\nfunction filter1D(intensity, kernel, horizontal) {\n  var size = Math.round((kernel.length - 1) / 2),\n    paddedData = padImage(intensity,\n      (horizontal) ? [size, 0] : [0, size]),\n    data = paddedData.data,\n    width = paddedData.width,\n    height = paddedData.height,\n    temporaryData = new Float32Array(data.length),\n    i, j, k, offset, value;\n  if (horizontal) {\n    for (i = 0; i < height; ++i) {\n      for (j = size; j < width - size; ++j) {\n        offset = i * width + j;\n        value = kernel[size] * data[offset];\n        for (k = 1; k <= size; ++k) {\n          value += kernel[size + k] * data[offset + k] +\n            kernel[size - k] * data[offset - k];\n        }\n        temporaryData[offset] = value;\n      }\n    }\n  }\n  else {\n    for (i = size; i < height - size; ++i) {\n      for (j = 0; j < width; ++j) {\n        offset = i * width + j;\n        value = kernel[size] * data[offset];\n        for (k = 1; k <= size; ++k) {\n          value += kernel[size + k] * data[offset + width * k] +\n            kernel[size - k] * data[offset - width * k];\n        }\n        temporaryData[offset] = value;\n      }\n    }\n  }\n  paddedData.data.set(temporaryData);\n  return padImage(paddedData, (horizontal) ? [-size, 0] : [0, -size]);\n}\n\nfunction filter1DTwice(intensity, kernel) {\n  return filter1D(filter1D(intensity, kernel, true), kernel, false);\n}\n\nfunction detectEdges(intensity, options) {\n  var width = intensity.width,\n    height = intensity.height,\n    magnitude = new Float32Array(intensity.data.length),\n    orientation = new Float32Array(intensity.data.length),\n    suppressed = new Float32Array(intensity.data.length),\n    result = createIntensityData(width, height),\n    SobelKernel = [-1, 0, 1],\n    dx = filter1D(intensity, SobelKernel, true),\n    dy = filter1D(intensity, SobelKernel, false),\n    i, j, direction, offset, offset1, offset2;\n  for (i = 0; i < intensity.data.length; ++i) {\n    magnitude[i] = Math.sqrt(Math.pow(dx.data[i], 2) +\n      Math.pow(dy.data[i], 2));\n    direction = Math.atan2(dy.data[i], dx.data[i]);\n    orientation[i] = (direction < 0) ? direction + Math.PI :\n      (direction > Math.PI) ? direction - Math.PI : direction;\n  }\n  // NMS.\n  for (i = 1; i < height - 1; ++i) {\n    for (j = 1; j < width - 1; ++j) {\n      offset = i * width + j;\n      direction = orientation[offset];\n      if (direction < Math.PI / 8 || 7 * Math.PI / 8 <= direction) {\n        offset1 = offset - 1;\n        offset2 = offset + 1;\n      }\n      else if (Math.PI / 8 <= direction && direction < 3 * Math.PI / 8) {\n        offset1 = offset - width - 1;\n        offset2 = offset + width + 1;\n      }\n      else if (3 * Math.PI / 8 <= direction && direction < 5 * Math.PI / 8) {\n        offset1 = offset - width;\n        offset2 = offset + width;\n      }\n      else if (5 * Math.PI / 8 <= direction && direction < 7 * Math.PI / 8) {\n        offset1 = offset - width + 1;\n        offset2 = offset + width - 1;\n      }\n      suppressed[offset] = (magnitude[offset] > magnitude[offset1] &&\n        magnitude[offset] > magnitude[offset2]) ?\n        magnitude[offset] : 0;\n    }\n  }\n  // Hysteresis.\n  for (i = 1; i < height - 1; ++i) {\n    for (j = 1; j < width - 1; ++j) {\n      offset = i * width + j;\n      direction = orientation[offset] - 0.5 * Math.PI;\n      direction = (direction < 0) ? direction + Math.PI : direction;\n      if (direction < Math.PI / 8 || 7 * Math.PI / 8 <= direction) {\n        offset1 = offset - 1;\n        offset2 = offset + 1;\n      }\n      else if (Math.PI / 8 <= direction && direction < 3 * Math.PI / 8) {\n        offset1 = offset - width - 1;\n        offset2 = offset + width + 1;\n      }\n      else if (3 * Math.PI / 8 <= direction && direction < 5 * Math.PI / 8) {\n        offset1 = offset - width;\n        offset2 = offset + width;\n      }\n      else if (5 * Math.PI / 8 <= direction && direction < 7 * Math.PI / 8) {\n        offset1 = offset - width + 1;\n        offset2 = offset + width - 1;\n      }\n      result.data[offset] =\n        (suppressed[offset] >= options.highThreshold ||\n          (suppressed[offset] >= options.lowThreshold &&\n            suppressed[offset1] >= options.highThreshold) ||\n          (suppressed[offset] >= options.lowThreshold &&\n            suppressed[offset2] >= options.highThreshold)) ?\n          suppressed[offset] : 0;\n    }\n  }\n  result.magnitude = magnitude;\n  return result;\n}\n\nfunction canny(imageData, options) {\n  options = options || {};\n  options.kernelTail = options.kernelTail || 4;\n  options.sigma = options.sigma || 1.6;\n  options.highThreshold = options.highThreshold || 0.04;\n  options.lowThreshold = options.lowThreshold || 0.3 * options.highThreshold;\n  var intensity = rgb2intensity(imageData);\n  var gaussianKernel = createGaussian1D(options.kernelTail, options.sigma);\n  var blurredData = filter1DTwice(intensity, gaussianKernel);\n  var edge = detectEdges(blurredData, options);\n  return edge;\n}\n\nexports.canny = canny\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/canny.js\n// module id = 12\n// module chunks = 0","/** Distance transform implementation based on the following paper.\n *\n * Distance Transforms of Sampled Functions\n * P. Felzenszwalb, D. Huttenlocher\n * Theory of Computing, Vol. 8, No. 19, September 2012\n *\n * Copyright 2015  Kota Yamaguchi\n */\n'use strict';\nconst INF = 1e20;\n\nfunction distanceTransform1D(f, n) {\n  var d = new Float32Array(n),\n    v = new Int32Array(n),\n    z = new Float32Array(n + 1),\n    k = 0,\n    square = function (x) { return x * x; },\n    q;\n  v[0] = 0;\n  z[0] = -INF;\n  z[1] = INF;\n  for (q = 1; q <= n - 1; ++q) {\n    var s = ((f[q] + square(q)) - (f[v[k]] + square(v[k]))) /\n      (2 * q - 2 * v[k]);\n    if (isNaN(s))\n      throw \"NaN error\";\n    while (s <= z[k]) {\n      --k;\n      s = ((f[q] + square(q)) - (f[v[k]] + square(v[k]))) /\n        (2 * q - 2 * v[k]);\n      if (isNaN(s))\n        throw \"NaN error\";\n    }\n    ++k;\n    v[k] = q;\n    z[k] = s;\n    z[k + 1] = INF;\n  }\n  k = 0;\n  for (q = 0; q <= n - 1; ++q) {\n    while (z[k + 1] < q)\n      k++;\n    d[q] = square(q - v[k]) + f[v[k]];\n  }\n  return d;\n}\n\nfunction distanceTransform2D(distanceMap) {\n  var width = distanceMap.width,\n    height = distanceMap.height,\n    data = distanceMap.data,\n    f = new Float32Array(Math.max(width, height)),\n    x, y, d;\n  // Column transform.\n  for (x = 0; x < width; ++x) {\n    for (y = 0; y < height; ++y)\n      f[y] = data[y * width + x];\n    d = distanceTransform1D(f, height);\n    for (y = 0; y < height; ++y)\n      data[y * width + x] = d[y];\n  }\n  // Row transform.\n  for (y = 0; y < height; ++y) {\n    for (x = 0; x < width; ++x)\n      f[x] = data[y * width + x];\n    d = distanceTransform1D(f, width);\n    for (x = 0; x < width; ++x)\n      data[y * width + x] = d[x];\n  }\n  // Sqrt.\n  for (x = 0; x < data.length; ++x)\n    data[x] = Math.sqrt(data[x]);\n}\n\nfunction distanceTransform(intensity, options) {\n  options = options || {};\n  var distanceMap = {\n    width: intensity.width,\n    height: intensity.height,\n    data: new Float32Array(intensity.data.length)\n  };\n  for (var offset = 0; offset < distanceMap.data.length; ++offset)\n    distanceMap.data[offset] = (intensity.data[offset]) ? 0 : INF;\n  distanceTransform2D(distanceMap);\n  //if (options.outputRGB)\n  //  distanceMap = intensity2rgb(distanceMap);\n  return distanceMap;\n}\n\nexports = {\n  distanceTransform: distanceTransform\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/distance-transform.js\n// module id = 13\n// module chunks = 0","/** Image morphology operations and index image I/O.\n *\n * Copyright 2015  Kota Yamaguchi\n */\n\nvar compat = require('./compat');\nvar maxFilter = require('./morph/max-filter');\n\nfunction decodeIndexImage(imageData) {\n  var indexImage = {\n    width: imageData.width,\n    height: imageData.height,\n    data: new Int32Array(imageData.width * imageData.height)\n  };\n  for (var i = 0; i < imageData.data.length; ++i) {\n    var offset = 4 * i;\n    indexImage.data[i] = (imageData.data[offset + 0]) |\n      (imageData.data[offset + 1] << 8) |\n      (imageData.data[offset + 2] << 16);\n  }\n  return indexImage;\n}\n\nfunction encodeIndexImage(indexImage) {\n  var imageData = compat.createImageData(indexImage.width, indexImage.height);\n  for (var i = 0; i < indexImage.length; ++i) {\n    var offset = 4 * i,\n      value = indexImage.data[i];\n    imageData.data[offset] = 255 & value;\n    imageData.data[offset + 1] = 255 & (value >>> 8);\n    imageData.data[offset + 2] = 255 & (value >>> 16);\n    imageData.data[offset + 3] = 255;\n  }\n  return imageData;\n}\n\nexports = {\n  encodeIndexImage: encodeIndexImage,\n  decodeIndexImage: decodeIndexImage,\n  maxFilter: maxFilter\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/morph.js\n// module id = 14\n// module chunks = 0","/** Max filter for an index image.\n *\n * Copyright 2015  Kota Yamaguchi\n */\nvar NeighborMap = require('./neighbor-map');\nfunction findDominantLabel(data, neighbors) {\n  var histogram = {},\n    i, label;\n  for (i = 0; i < neighbors.length; ++i) {\n    label = data[neighbors[i]];\n    if (histogram[label])\n      ++histogram[label];\n    else\n      histogram[label] = 1;\n  }\n  var labels = Object.keys(histogram),\n    count = 0,\n    dominantLabel = null;\n  for (i = 0; i < labels.length; ++i) {\n    label = labels[i];\n    if (histogram[label] > count) {\n      dominantLabel = parseInt(label, 10);\n      count = histogram[label];\n    }\n  }\n  return dominantLabel;\n}\n\nfunction maxFilter(indexImage, options) {\n  options = options || {};\n  var neighbors = options.neighbors || [[-1, -1], [-1, 0], [-1, 1],\n  [0, -1], [0, 0], [0, 1],\n  [1, -1], [1, 0], [1, 1]],\n    result = new Int32Array(indexImage.data.length),\n    neighborMap = new NeighborMap(indexImage.width,\n      indexImage.height,\n      neighbors);\n  for (var i = 0; i < indexImage.data.length; ++i)\n    result[i] = findDominantLabel(indexImage.data,\n      neighborMap.get(i));\n  return {\n    width: indexImage.width,\n    height: indexImage.height,\n    data: result\n  };\n}\n\nexports = maxFilter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/morph/max-filter.js\n// module id = 15\n// module chunks = 0","/** Create a map of neighbor offsets.\n *\n *  var neighborMap = new NeighborMap(width, height);\n *  for (var i = 0; i < data.length; ++i) {\n *    var neighbors = neighborMap.get(i);\n *    for (var j = 0; j < neighbors.length; ++j) {\n *      var pixel = data[neighbors[j]];\n *    }\n *  }\n *\n * Copyright 2015  Kota Yamaguchi\n */\nfunction NeighborMap(width, height, neighbors) {\n  this.neighbors = neighbors || [[-1, -1], [-1, 0], [-1, 1],\n  [0, -1], [0, 1],\n  [1, -1], [1, 0], [1, 1]];\n  this.maps = [];\n  for (var k = 0; k < this.neighbors.length; ++k) {\n    var dy = this.neighbors[k][0],\n      dx = this.neighbors[k][1],\n      map = new Int32Array(width * height);\n    for (var y = 0; y < height; ++y) {\n      for (var x = 0; x < width; ++x) {\n        var Y = y + dy,\n          X = x + dx;\n        map[y * width + x] = (Y < 0 || height <= Y || X < 0 || width <= X) ?\n          -1 : Y * width + X;\n      }\n    }\n    this.maps.push(map);\n  }\n}\n\nNeighborMap.prototype.get = function (offset) {\n  var neighborOffsets = [];\n  for (var k = 0; k < this.neighbors.length; ++k) {\n    var neighborOffset = this.maps[k][offset];\n    if (neighborOffset >= 0)\n      neighborOffsets.push(neighborOffset);\n  }\n  return neighborOffsets;\n};\n\nexports = NeighborMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/image/morph/neighbor-map.js\n// module id = 16\n// module chunks = 0","/** Misc utilities regarding HTTP request.\n */\ndefine(function () {\n  // Get JSON by AJAX request.\n  function requestJSON(url, callback) {\n    var xmlhttp = new XMLHttpRequest();\n    xmlhttp.onreadystatechange = function() {\n      if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n        var data = xmlhttp.responseText;\n        callback(JSON.parse(data));\n      }\n    };\n    xmlhttp.open(\"GET\", url, true);\n    xmlhttp.send();\n  }\n\n  // Parse query params.\n  function getQueryParams(queryString) {\n    var tokens,\n        params = {},\n        re = /[?&]?([^=]+)=([^&]*)/g;\n    queryString = queryString || document.location.search;\n    while (tokens = re.exec(queryString.split(\"+\").join(\" \")))\n        params[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);\n    return params;\n  }\n\n  // Create a unique array.\n  function unique() {\n    var uniqueArray = [];\n    for (var i = 0; i < arguments.length; ++i) {\n      var array = arguments[i];\n      for (var j = 0; j < array.length; ++j) {\n        if (uniqueArray.indexOf(array[j]) < 0)\n          uniqueArray.push(array[j]);\n      }\n    }\n    return uniqueArray;\n  }\n\n  // Create query params from an object.\n  function makeQueryParams(params, updates) {\n    params = params || {};\n    updates = updates || {};\n    var queryString = \"?\";\n    var keys = unique(Object.keys(params), Object.keys(updates));\n    for (var i = 0; i < keys.length; ++i) {\n      var value = updates[keys[i]];\n      if (value === null)\n        continue;\n      else if (typeof value === \"undefined\")\n        value = params[keys[i]];\n      queryString = queryString +\n                    encodeURIComponent(keys[i]) + \"=\" +\n                    encodeURIComponent(value) +\n                    ((i < keys.length - 1) ? \"&\" : \"\");\n    }\n    return queryString;\n  }\n\n  return {\n    requestJSON: requestJSON,\n    getQueryParams: getQueryParams,\n    makeQueryParams: makeQueryParams\n  };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/helper/util.js\n// module id = 17\n// module chunks = 0","/** Colormap generator.\n *\n * Example:\n *\n *   define([\"./colormap\"], function (colormap) {\n *     var randomColor = colormap.create(\"random\", { size: 16 });\n *     var grayColor = colormap.create(\"gray\", { size: 16 });\n *     var hsvColor = colormap.create(\"hsv\", { size: 256 });\n *     // ...\n *   });\n *\n * Copyright 2015  Kota Yamaguchi\n */\nvar registry = {\n  random: function (options) {\n    var colormap = [];\n    for (var i = 0; i < options.size; ++i)\n      colormap.push([Math.floor(256 * Math.random()),\n      Math.floor(256 * Math.random()),\n      Math.floor(256 * Math.random())]);\n    return colormap;\n  },\n  gray: function (options) {\n    var colormap = [];\n    for (var i = 0; i < options.size; ++i) {\n      var intensity = Math.round(255 * i / options.size);\n      colormap.push([intensity, intensity, intensity]);\n    }\n    return colormap;\n  },\n  hsv: function (options) {\n    var colormap = [],\n      saturation = (options.saturation === undefined) ?\n        1 : options.saturation;\n    for (var i = 0; i < options.size; ++i)\n      colormap.push(hsv2rgb(i / options.size, saturation, 1));\n    return colormap;\n  },\n  hhsv: function (options) {\n    var colormap = [],\n      depth = options.depth || 2,\n      saturationBlocks = [],\n      i;\n    for (i = 0; i < depth; ++i)\n      saturationBlocks[i] = 0;\n    for (i = 0; i < options.size; ++i)\n      saturationBlocks[Math.floor(depth * i / options.size)] += 1;\n    for (i = 0; i < depth; ++i) {\n      colormap = colormap.concat(registry.hsv({\n        size: saturationBlocks[i],\n        saturation: 1 - (i / depth)\n      }));\n    }\n    return colormap;\n  },\n  single: function (options) {\n    var colormap = [];\n    for (var i = 0; i < options.size; ++i) {\n      if (i === options.index)\n        colormap.push(options.foreground || [255, 0, 0]);\n      else\n        colormap.push(options.background || [255, 255, 255]);\n    }\n    return colormap;\n  }\n};\n\n/** Compute RGB value from HSV.\n */\nfunction hsv2rgb(h, s, v) {\n  var i = Math.floor(h * 6),\n    f = h * 6 - i,\n    p = v * (1 - s),\n    q = v * (1 - f * s),\n    t = v * (1 - (1 - f) * s),\n    r, g, b;\n  switch (i % 6) {\n    case 0: r = v; g = t; b = p; break;\n    case 1: r = q; g = v; b = p; break;\n    case 2: r = p; g = v; b = t; break;\n    case 3: r = p; g = q; b = v; break;\n    case 4: r = t; g = p; b = v; break;\n    case 5: r = v; g = p; b = q; break;\n  }\n  return [r, g, b].map(function (x) { return Math.round(x * 255); });\n}\n\nfunction create(name, options) {\n  if (typeof name === \"undefined\") name = \"random\";\n  if (typeof options === \"undefined\") options = {};\n  options.size = options.size || 8;\n  return registry[name](options);\n}\n\nfunction register(name, callback) {\n  register[name] = callback;\n}\n\nmodule.exports = {\n  create: create,\n  register: register\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./js/helper/colormap.js\n// module id = 18\n// module chunks = 0"],"sourceRoot":""}